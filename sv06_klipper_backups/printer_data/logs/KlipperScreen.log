2023-11-18 16:40:43,031 [functions.py:log_start()] - --------------------KlipperScreen Log Start--------------------
2023-11-18 16:40:43,032 [functions.py:log_start()] - KlipperScreen Version: v0.3.6-85-gad3b935
2023-11-18 16:40:43,032 [functions.py:log_start()] - Python version: 3.9
2023-11-18 16:40:43,322 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-11-18 16:40:43,326 [config.py:__init__()] - Config path location: /home/biqu/KlipperScreen/ks_includes/defaults.conf
2023-11-18 16:40:43,358 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-11-18 16:40:43,490 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-11-18 16:40:43,491 [config.py:install_language()] - Using system lang
2023-11-18 16:40:43,492 [config.py:install_language()] - Using lang en
2023-11-18 16:40:43,532 [screen.py:__init__()] - Screen resolution: 1024x600
2023-11-18 16:40:43,536 [KlippyGtk.py:__init__()] - Font size: 20.7 (medium)
2023-11-18 16:40:44,712 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-11-18 16:40:44,726 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-11-18 16:40:44,737 [screen.py:initial_connection()] - Default printer: None
2023-11-18 16:40:44,738 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-11-18 16:40:44,738 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-11-18 16:40:44,832 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-18 16:40:44,850 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-11-18 16:40:44,886 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 16:40:44,909 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-11-18 16:40:44,911 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-11-18 16:40:44,929 [_logging.py:info()] - Websocket connected
2023-11-18 16:40:44,930 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-11-18 16:40:45,002 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 16:40:45,022 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 16:40:45,025 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'history', 'update_manager', 'authorization'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-18 16:40:45,045 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-18 16:40:45,047 [printer.py:configure_cameras()] - Cameras: []
2023-11-18 16:40:45,071 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-18 16:40:45,100 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-18 16:40:45,102 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '/home/biqu/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu': {'serial': '/dev/serial/by-id/<your-mcu-id>'}, 'printer': {'kinematics': 'none', 'max_velocity': '1000', 'max_accel': '1000'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-id/<your-mcu-id>', 'baud': 250000, 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '/home/biqu/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'printer': {'max_velocity': 1000.0, 'max_accel': 1000.0, 'max_accel_to_decel': 500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'none'}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-18 16:40:45,105 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1
2023-11-18 16:40:45,106 [printer.py:reinit()] - # Extruders: 0
2023-11-18 16:40:45,106 [printer.py:reinit()] - # Temperature devices: 0
2023-11-18 16:40:45,107 [printer.py:reinit()] - # Fans: 0
2023-11-18 16:40:45,107 [printer.py:reinit()] - # Output pins: 0
2023-11-18 16:40:45,108 [printer.py:reinit()] - # Leds: 0
2023-11-18 16:40:45,133 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-18 16:40:45,136 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-18 16:40:45,388 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe
2023-11-18 16:40:45,394 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-18 16:40:45,395 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-18 16:40:45,396 [screen.py:init_printer()] - Printer initialized
2023-11-18 16:40:45,397 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-18 16:40:45,398 [printer.py:change_state()] - Adding callback for state: startup
2023-11-18 16:42:43,154 [printer.py:change_state()] - Changing state from 'startup' to 'error'
2023-11-18 16:42:43,155 [printer.py:change_state()] - Adding callback for state: error
2023-11-18 16:42:43,158 [screen.py:show_panel()] - Reinitializing panel
2023-11-18 16:42:43,247 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-18 16:45:08,638 [functions.py:log_start()] - --------------------KlipperScreen Log Start--------------------
2023-11-18 16:45:08,640 [functions.py:log_start()] - KlipperScreen Version: v0.3.6-85-gad3b935
2023-11-18 16:45:08,640 [functions.py:log_start()] - Python version: 3.9
2023-11-18 16:45:09,251 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-11-18 16:45:09,254 [config.py:__init__()] - Config path location: /home/biqu/KlipperScreen/ks_includes/defaults.conf
2023-11-18 16:45:09,294 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-11-18 16:45:09,445 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-11-18 16:45:09,446 [config.py:install_language()] - Using system lang
2023-11-18 16:45:09,448 [config.py:install_language()] - Using lang en
2023-11-18 16:45:09,508 [screen.py:__init__()] - Screen resolution: 1024x600
2023-11-18 16:45:09,514 [KlippyGtk.py:__init__()] - Font size: 20.7 (medium)
2023-11-18 16:45:12,908 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-11-18 16:45:12,926 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-11-18 16:45:12,945 [screen.py:initial_connection()] - Default printer: None
2023-11-18 16:45:12,945 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-11-18 16:45:12,946 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-11-18 16:45:13,074 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-18 16:45:13,098 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-11-18 16:45:13,169 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 16:45:13,193 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-11-18 16:45:13,196 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-11-18 16:45:13,214 [_logging.py:info()] - Websocket connected
2023-11-18 16:45:13,214 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-11-18 16:45:13,368 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 16:45:13,398 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 16:45:13,400 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'history', 'authorization', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-18 16:45:13,429 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-18 16:45:13,432 [printer.py:configure_cameras()] - Cameras: []
2023-11-18 16:45:13,433 [screen.py:init_printer()] - Klipper not connected
2023-11-18 16:45:16,503 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 16:45:16,533 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 16:45:16,536 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'history', 'authorization', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-18 16:45:16,560 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-18 16:45:16,563 [printer.py:configure_cameras()] - Cameras: []
2023-11-18 16:45:16,564 [screen.py:init_printer()] - Klipper not connected
2023-11-18 16:45:19,503 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 16:45:19,530 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 16:45:19,532 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'history', 'authorization', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-18 16:45:19,558 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-18 16:45:19,560 [printer.py:configure_cameras()] - Cameras: []
2023-11-18 16:45:19,602 [KlippyRest.py:_do_request()] - 404 Client Error>>Not Found for url>>http://127.0.0.1:7125/printer/info
2023-11-18 16:45:22,496 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 16:45:22,517 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 16:45:22,519 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'history', 'authorization', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-18 16:45:22,539 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-18 16:45:22,541 [printer.py:configure_cameras()] - Cameras: []
2023-11-18 16:45:22,565 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-18 16:45:22,593 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-18 16:45:22,596 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '/home/biqu/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu': {'serial': '/dev/serial/by-id/<your-mcu-id>'}, 'printer': {'kinematics': 'none', 'max_velocity': '1000', 'max_accel': '1000'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-id/<your-mcu-id>', 'baud': 250000, 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '/home/biqu/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'printer': {'max_velocity': 1000.0, 'max_accel': 1000.0, 'max_accel_to_decel': 500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'none'}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-18 16:45:22,598 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1
2023-11-18 16:45:22,599 [printer.py:reinit()] - # Extruders: 0
2023-11-18 16:45:22,599 [printer.py:reinit()] - # Temperature devices: 0
2023-11-18 16:45:22,599 [printer.py:reinit()] - # Fans: 0
2023-11-18 16:45:22,600 [printer.py:reinit()] - # Output pins: 0
2023-11-18 16:45:22,600 [printer.py:reinit()] - # Leds: 0
2023-11-18 16:45:22,626 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-18 16:45:22,628 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-18 16:45:22,881 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe
2023-11-18 16:45:22,886 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-18 16:45:22,887 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-18 16:45:22,888 [screen.py:init_printer()] - Printer initialized
2023-11-18 16:45:22,889 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-18 16:45:22,889 [printer.py:change_state()] - Adding callback for state: startup
2023-11-18 16:45:50,664 [KlippyWebsocket.py:restart_firmware()] - Sending printer.firmware_restart
2023-11-18 16:45:51,766 [printer.py:change_state()] - Changing state from 'startup' to 'disconnected'
2023-11-18 16:45:51,767 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-18 16:45:51,769 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-18 16:45:51,772 [screen.py:show_panel()] - Reinitializing panel
2023-11-18 16:45:51,874 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-18 16:45:55,503 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 16:45:55,530 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 16:45:55,532 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'history', 'authorization', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-18 16:45:55,556 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-18 16:45:55,558 [printer.py:configure_cameras()] - Cameras: []
2023-11-18 16:45:55,585 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-18 16:45:55,617 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-18 16:45:55,620 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '/home/biqu/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu': {'serial': '/dev/serial/by-id/<your-mcu-id>'}, 'printer': {'kinematics': 'none', 'max_velocity': '1000', 'max_accel': '1000'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-id/<your-mcu-id>', 'baud': 250000, 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '/home/biqu/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'printer': {'max_velocity': 1000.0, 'max_accel': 1000.0, 'max_accel_to_decel': 500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'none'}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-18 16:45:55,623 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1
2023-11-18 16:45:55,623 [printer.py:reinit()] - # Extruders: 0
2023-11-18 16:45:55,624 [printer.py:reinit()] - # Temperature devices: 0
2023-11-18 16:45:55,624 [printer.py:reinit()] - # Fans: 0
2023-11-18 16:45:55,625 [printer.py:reinit()] - # Output pins: 0
2023-11-18 16:45:55,626 [printer.py:reinit()] - # Leds: 0
2023-11-18 16:45:55,655 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-18 16:45:55,658 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-18 16:45:55,907 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe
2023-11-18 16:45:55,913 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-18 16:45:55,913 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-18 16:45:55,916 [screen.py:init_printer()] - Printer initialized
2023-11-18 16:45:55,918 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-18 16:45:55,918 [printer.py:change_state()] - Adding callback for state: startup
2023-11-18 16:46:03,889 [KlippyWebsocket.py:connect()] - Already connected
2023-11-18 16:46:07,040 [KlippyWebsocket.py:restart_firmware()] - Sending printer.firmware_restart
2023-11-18 16:46:08,117 [printer.py:change_state()] - Changing state from 'startup' to 'disconnected'
2023-11-18 16:46:08,117 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-18 16:46:08,119 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-18 16:46:08,125 [screen.py:show_panel()] - Reinitializing panel
2023-11-18 16:46:08,225 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-18 16:46:11,498 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 16:46:11,519 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 16:46:11,522 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'history', 'authorization', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-18 16:46:11,542 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-18 16:46:11,544 [printer.py:configure_cameras()] - Cameras: []
2023-11-18 16:46:11,567 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-18 16:46:11,596 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-18 16:46:11,598 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '/home/biqu/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu': {'serial': '/dev/serial/by-id/<your-mcu-id>'}, 'printer': {'kinematics': 'none', 'max_velocity': '1000', 'max_accel': '1000'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-id/<your-mcu-id>', 'baud': 250000, 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '/home/biqu/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'printer': {'max_velocity': 1000.0, 'max_accel': 1000.0, 'max_accel_to_decel': 500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'none'}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-18 16:46:11,600 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1
2023-11-18 16:46:11,601 [printer.py:reinit()] - # Extruders: 0
2023-11-18 16:46:11,601 [printer.py:reinit()] - # Temperature devices: 0
2023-11-18 16:46:11,601 [printer.py:reinit()] - # Fans: 0
2023-11-18 16:46:11,602 [printer.py:reinit()] - # Output pins: 0
2023-11-18 16:46:11,602 [printer.py:reinit()] - # Leds: 0
2023-11-18 16:46:11,628 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-18 16:46:11,630 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-18 16:46:11,898 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe
2023-11-18 16:46:11,902 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-18 16:46:11,904 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-18 16:46:11,906 [screen.py:init_printer()] - Printer initialized
2023-11-18 16:46:11,909 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-18 16:46:11,910 [printer.py:change_state()] - Adding callback for state: startup
2023-11-18 16:46:39,656 [KlippyWebsocket.py:restart()] - Sending printer.restart
2023-11-18 16:46:39,672 [printer.py:change_state()] - Changing state from 'startup' to 'disconnected'
2023-11-18 16:46:39,673 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-18 16:46:39,675 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-18 16:46:39,678 [screen.py:show_panel()] - Reinitializing panel
2023-11-18 16:46:39,765 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-18 16:46:43,505 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 16:46:43,535 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 16:46:43,537 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'history', 'authorization', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-18 16:46:43,565 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-18 16:46:43,568 [printer.py:configure_cameras()] - Cameras: []
2023-11-18 16:46:43,598 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-18 16:46:43,637 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-18 16:46:43,641 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '/home/biqu/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu': {'serial': '/dev/serial/by-id/<your-mcu-id>'}, 'printer': {'kinematics': 'none', 'max_velocity': '1000', 'max_accel': '1000'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-id/<your-mcu-id>', 'baud': 250000, 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '/home/biqu/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'printer': {'max_velocity': 1000.0, 'max_accel': 1000.0, 'max_accel_to_decel': 500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'none'}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-18 16:46:43,644 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1
2023-11-18 16:46:43,645 [printer.py:reinit()] - # Extruders: 0
2023-11-18 16:46:43,645 [printer.py:reinit()] - # Temperature devices: 0
2023-11-18 16:46:43,646 [printer.py:reinit()] - # Fans: 0
2023-11-18 16:46:43,647 [printer.py:reinit()] - # Output pins: 0
2023-11-18 16:46:43,647 [printer.py:reinit()] - # Leds: 0
2023-11-18 16:46:43,686 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-18 16:46:43,689 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-18 16:46:43,931 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe
2023-11-18 16:46:43,934 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-18 16:46:43,935 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-18 16:46:43,937 [screen.py:init_printer()] - Printer initialized
2023-11-18 16:46:43,938 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-18 16:46:43,938 [printer.py:change_state()] - Adding callback for state: startup
2023-11-18 16:48:11,403 [printer.py:change_state()] - Changing state from 'startup' to 'error'
2023-11-18 16:48:11,404 [printer.py:change_state()] - Adding callback for state: error
2023-11-18 16:48:11,408 [screen.py:show_panel()] - Reinitializing panel
2023-11-18 16:48:11,511 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-18 17:04:17,762 [KlippyWebsocket.py:restart_firmware()] - Sending printer.firmware_restart
2023-11-18 17:04:18,835 [printer.py:change_state()] - Changing state from 'error' to 'disconnected'
2023-11-18 17:04:18,835 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-18 17:04:18,839 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-18 17:04:18,842 [screen.py:show_panel()] - Reinitializing panel
2023-11-18 17:04:18,943 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-18 17:04:22,497 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 17:04:22,518 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 17:04:22,520 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'history', 'authorization', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 3, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-18 17:04:22,540 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-18 17:04:22,542 [printer.py:configure_cameras()] - Cameras: []
2023-11-18 17:04:22,566 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-18 17:04:22,595 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-18 17:04:22,598 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '/home/biqu/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu': {'serial': '/dev/serial/by-id/<your-mcu-id>'}, 'printer': {'kinematics': 'none', 'max_velocity': '1000', 'max_accel': '1000'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-id/<your-mcu-id>', 'baud': 250000, 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '/home/biqu/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'printer': {'max_velocity': 1000.0, 'max_accel': 1000.0, 'max_accel_to_decel': 500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'none'}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-18 17:04:22,600 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1
2023-11-18 17:04:22,600 [printer.py:reinit()] - # Extruders: 0
2023-11-18 17:04:22,600 [printer.py:reinit()] - # Temperature devices: 0
2023-11-18 17:04:22,601 [printer.py:reinit()] - # Fans: 0
2023-11-18 17:04:22,601 [printer.py:reinit()] - # Output pins: 0
2023-11-18 17:04:22,601 [printer.py:reinit()] - # Leds: 0
2023-11-18 17:04:22,627 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-18 17:04:22,629 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-18 17:04:22,881 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe
2023-11-18 17:04:22,885 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-18 17:04:22,886 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-18 17:04:22,887 [screen.py:init_printer()] - Printer initialized
2023-11-18 17:04:22,888 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-18 17:04:22,889 [printer.py:change_state()] - Adding callback for state: startup
2023-11-18 17:05:49,862 [printer.py:change_state()] - Changing state from 'startup' to 'error'
2023-11-18 17:05:49,862 [printer.py:change_state()] - Adding callback for state: error
2023-11-18 17:05:49,867 [screen.py:show_panel()] - Reinitializing panel
2023-11-18 17:05:49,956 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-18 17:08:18,416 [printer.py:change_state()] - Changing state from 'error' to 'disconnected'
2023-11-18 17:08:18,416 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-18 17:08:18,417 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-18 17:08:18,421 [screen.py:show_panel()] - Reinitializing panel
2023-11-18 17:08:18,523 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-18 17:08:21,502 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 17:08:21,540 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 17:08:21,542 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'history', 'authorization', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 3, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-18 17:08:21,565 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-18 17:08:21,567 [printer.py:configure_cameras()] - Cameras: []
2023-11-18 17:08:21,737 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-18 17:08:21,787 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-18 17:08:21,791 [screen.py:init_printer()] - {'configfile': {'config': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'control': 'pid', 'pid_kd': '86.991', 'pid_kp': '21.479', 'pid_ki': '1.326', 'min_temp': '0', 'max_temp': '300'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'control': 'pid', 'pid_kp': '64.440', 'pid_ki': '0.773', 'pid_kd': '1343.571', 'min_temp': '0', 'max_temp': '130'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'z_offset': '0', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 21.479, 'pid_ki': 1.326, 'pid_kd': 86.991, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 64.44, 'pid_ki': 0.773, 'pid_kd': 1343.571, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': 0.0, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-18 17:08:21,795 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1
2023-11-18 17:08:21,795 [printer.py:reinit()] - # Extruders: 1
2023-11-18 17:08:21,796 [printer.py:reinit()] - # Temperature devices: 1
2023-11-18 17:08:21,797 [printer.py:reinit()] - # Fans: 1
2023-11-18 17:08:21,797 [printer.py:reinit()] - # Output pins: 0
2023-11-18 17:08:21,798 [printer.py:reinit()] - # Leds: 0
2023-11-18 17:08:21,830 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-18 17:08:21,833 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-18 17:08:22,079 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-11-18 17:08:22,104 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-18 17:08:22,106 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-11-18 17:08:22,107 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-18 17:08:22,108 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-18 17:08:22,110 [screen.py:init_printer()] - Printer initialized
2023-11-18 17:08:22,111 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-18 17:08:22,112 [printer.py:change_state()] - Adding callback for state: startup
2023-11-18 17:08:23,033 [printer.py:change_state()] - Changing state from 'startup' to 'error'
2023-11-18 17:08:23,034 [printer.py:change_state()] - Adding callback for state: error
2023-11-18 17:08:23,039 [screen.py:show_panel()] - Reinitializing panel
2023-11-18 17:08:23,146 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-18 17:08:27,496 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-18 17:08:27,498 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-11-18 17:08:32,364 [printer.py:change_state()] - Changing state from 'error' to 'disconnected'
2023-11-18 17:08:32,365 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-18 17:08:32,367 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-18 17:08:32,370 [screen.py:show_panel()] - Reinitializing panel
2023-11-18 17:08:32,458 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-18 17:08:32,521 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-18 17:08:32,523 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-11-18 17:08:35,502 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 17:08:35,527 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 17:08:35,529 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'history', 'authorization', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 3, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-18 17:08:35,556 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-18 17:08:35,559 [printer.py:configure_cameras()] - Cameras: []
2023-11-18 17:08:36,146 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-18 17:08:36,190 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-18 17:08:36,194 [screen.py:init_printer()] - {'configfile': {'config': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'control': 'pid', 'pid_kd': '86.991', 'pid_kp': '21.479', 'pid_ki': '1.326', 'min_temp': '0', 'max_temp': '300'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'control': 'pid', 'pid_kp': '64.440', 'pid_ki': '0.773', 'pid_kd': '1343.571', 'min_temp': '0', 'max_temp': '130'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'z_offset': '0', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 21.479, 'pid_ki': 1.326, 'pid_kd': 86.991, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 64.44, 'pid_ki': 0.773, 'pid_kd': 1343.571, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': 0.0, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-18 17:08:36,198 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1
2023-11-18 17:08:36,198 [printer.py:reinit()] - # Extruders: 1
2023-11-18 17:08:36,199 [printer.py:reinit()] - # Temperature devices: 1
2023-11-18 17:08:36,200 [printer.py:reinit()] - # Fans: 1
2023-11-18 17:08:36,200 [printer.py:reinit()] - # Output pins: 0
2023-11-18 17:08:36,201 [printer.py:reinit()] - # Leds: 0
2023-11-18 17:08:36,231 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-18 17:08:36,234 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-18 17:08:36,476 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-11-18 17:08:36,516 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-18 17:08:36,519 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-11-18 17:08:36,520 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-18 17:08:36,521 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-18 17:08:36,527 [screen.py:init_printer()] - Printer initialized
2023-11-18 17:08:36,528 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-18 17:08:36,529 [printer.py:change_state()] - Adding callback for state: startup
2023-11-18 17:08:37,498 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-18 17:08:37,500 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-11-18 17:08:37,964 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-18 17:08:37,965 [printer.py:change_state()] - Adding callback for state: ready
2023-11-18 17:08:37,972 [screen.py:_load_panel()] - Loading panel: main_menu
2023-11-18 17:08:38,143 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-18 17:08:38,157 [main_menu.py:add_device()] - Adding device: extruder
2023-11-18 17:08:38,170 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-18 17:08:38,238 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-18 17:08:38,241 [main_menu.py:update_graph_visibility()] - Could not create graph tempstore: []
2023-11-18 17:08:41,499 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-18 17:08:41,525 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-11-18 17:08:41,549 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-18 17:08:41,552 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-18 17:08:42,500 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-18 17:08:42,528 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-11-18 17:08:42,562 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-18 17:08:42,567 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-18 17:21:34,141 [functions.py:log_start()] - --------------------KlipperScreen Log Start--------------------
2023-11-18 17:21:34,144 [functions.py:log_start()] - KlipperScreen Version: v0.3.6-85-gad3b935
2023-11-18 17:21:34,145 [functions.py:log_start()] - Python version: 3.9
2023-11-18 17:21:34,432 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-11-18 17:21:34,433 [config.py:__init__()] - Config path location: /home/biqu/KlipperScreen.conf
2023-11-18 17:21:34,474 [config.py:log_config()] -  ===== Config File =====
[main]

[printer sv06]
moonraker_host = localhost
moonraker_post = 7125
moonraker_api_key = [redacted]
=======================
2023-11-18 17:21:34,478 [config.py:__init__()] - ====== Saved Def ======

=======================
2023-11-18 17:21:34,480 [config.py:__init__()] - Configured printers: [
  {
    "sv06": {
      "moonraker_host": "localhost",
      "moonraker_port": "7125",
      "moonraker_api_key": "redacted"
    }
  }
]
2023-11-18 17:21:34,618 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-11-18 17:21:34,619 [config.py:install_language()] - Using system lang
2023-11-18 17:21:34,620 [config.py:install_language()] - Using lang en
2023-11-18 17:21:34,659 [screen.py:__init__()] - Screen resolution: 1024x600
2023-11-18 17:21:34,665 [KlippyGtk.py:__init__()] - Font size: 20.7 (medium)
2023-11-19 14:10:16,386 [screen.py:show_error_modal()] - Showing error modal: Invalid config file Option "moonraker_post" not recognized for section "[printer sv06]"


2023-11-19 14:10:16,553 [KlippyGtk.py:Dialog()] - Showing dialog Error (width=1028, height=600)
2023-11-19 14:10:16,570 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-11-19 14:10:16,587 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-11-19 14:10:16,601 [screen.py:initial_connection()] - Default printer: None
2023-11-19 14:10:16,602 [screen.py:connect_printer()] - Connecting to printer: sv06
2023-11-19 14:10:16,603 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-11-19 14:10:16,708 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-19 14:10:16,733 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-11-19 14:10:16,779 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/server/info
2023-11-19 14:10:16,815 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/access/oneshot_token
2023-11-19 14:10:16,819 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-11-19 14:10:16,845 [_logging.py:info()] - Websocket connected
2023-11-19 14:10:16,845 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-11-19 14:10:16,967 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/server/info
2023-11-19 14:10:16,995 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/server/info
2023-11-19 14:10:16,998 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'ready', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'authorization', 'octoprint_compat', 'history'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-19 14:10:17,024 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/server/webcams/list
2023-11-19 14:10:17,027 [printer.py:configure_cameras()] - Cameras: []
2023-11-19 14:10:17,082 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/printer/info
2023-11-19 14:10:17,189 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/printer/objects/query?configfile
2023-11-19 14:10:17,193 [screen.py:init_printer()] - {'configfile': {'config': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'control': 'pid', 'pid_kd': '86.991', 'pid_kp': '21.479', 'pid_ki': '1.326', 'min_temp': '0', 'max_temp': '300'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'control': 'pid', 'pid_kp': '64.440', 'pid_ki': '0.773', 'pid_kd': '1343.571', 'min_temp': '0', 'max_temp': '130'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'z_offset': '0', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 21.479, 'pid_ki': 1.326, 'pid_kd': 86.991, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 64.44, 'pid_ki': 0.773, 'pid_kd': 1343.571, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': 0.0, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-19 14:10:17,196 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1
2023-11-19 14:10:17,197 [printer.py:reinit()] - # Extruders: 1
2023-11-19 14:10:17,197 [printer.py:reinit()] - # Temperature devices: 1
2023-11-19 14:10:17,197 [printer.py:reinit()] - # Fans: 1
2023-11-19 14:10:17,198 [printer.py:reinit()] - # Output pins: 0
2023-11-19 14:10:17,198 [printer.py:reinit()] - # Leds: 0
2023-11-19 14:10:17,228 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/printer/gcode/help
2023-11-19 14:10:17,231 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-19 14:10:17,496 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-11-19 14:10:17,521 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/server/temperature_store
2023-11-19 14:10:17,547 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-11-19 14:10:17,570 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/server/config
2023-11-19 14:10:17,573 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-19 14:10:17,574 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-19 14:10:17,574 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-19 14:10:17,576 [screen.py:init_printer()] - Printer initialized
2023-11-19 14:10:17,577 [printer.py:change_state()] - Changing state from 'disconnected' to 'ready'
2023-11-19 14:10:17,577 [printer.py:change_state()] - Adding callback for state: ready
2023-11-19 14:10:17,592 [screen.py:_load_panel()] - Loading panel: main_menu
2023-11-19 14:10:17,753 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-19 14:10:17,767 [main_menu.py:add_device()] - Adding device: extruder
2023-11-19 14:10:17,780 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-19 14:10:17,844 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-19 14:10:41,649 [functions.py:log_start()] - --------------------KlipperScreen Log Start--------------------
2023-11-19 14:10:41,650 [functions.py:log_start()] - KlipperScreen Version: v0.3.6-85-gad3b935
2023-11-19 14:10:41,651 [functions.py:log_start()] - Python version: 3.9
2023-11-19 14:10:41,901 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-11-19 14:10:41,902 [config.py:__init__()] - Config path location: /home/biqu/KlipperScreen.conf
2023-11-19 14:10:41,954 [config.py:log_config()] -  ===== Config File =====
[main]

[printer sv06]
moonraker_host = localhost
moonraker_post = 7125
moonraker_api_key = [redacted]
=======================
2023-11-19 14:10:41,959 [config.py:__init__()] - ====== Saved Def ======

=======================
2023-11-19 14:10:41,962 [config.py:__init__()] - Configured printers: [
  {
    "sv06": {
      "moonraker_host": "localhost",
      "moonraker_port": "7125",
      "moonraker_api_key": "redacted"
    }
  }
]
2023-11-19 14:10:42,121 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-11-19 14:10:42,122 [config.py:install_language()] - Using system lang
2023-11-19 14:10:42,124 [config.py:install_language()] - Using lang en
2023-11-19 14:10:42,173 [screen.py:__init__()] - Screen resolution: 1024x600
2023-11-19 14:10:42,177 [KlippyGtk.py:__init__()] - Font size: 20.7 (medium)
2023-11-19 14:10:42,821 [screen.py:show_error_modal()] - Showing error modal: Invalid config file Option "moonraker_post" not recognized for section "[printer sv06]"


2023-11-19 14:10:42,953 [KlippyGtk.py:Dialog()] - Showing dialog Error (width=1028, height=600)
2023-11-19 14:10:42,965 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-11-19 14:10:42,979 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-11-19 14:10:42,992 [screen.py:initial_connection()] - Default printer: None
2023-11-19 14:10:42,992 [screen.py:connect_printer()] - Connecting to printer: sv06
2023-11-19 14:10:42,993 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-11-19 14:10:43,082 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-19 14:10:43,102 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-11-19 14:10:43,136 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/server/info
2023-11-19 14:10:43,159 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/access/oneshot_token
2023-11-19 14:10:43,161 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-11-19 14:10:43,181 [_logging.py:info()] - Websocket connected
2023-11-19 14:10:43,182 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-11-19 14:10:43,272 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/server/info
2023-11-19 14:10:43,295 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/server/info
2023-11-19 14:10:43,297 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'ready', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'authorization', 'octoprint_compat', 'history'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-19 14:10:43,319 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/server/webcams/list
2023-11-19 14:10:43,321 [printer.py:configure_cameras()] - Cameras: []
2023-11-19 14:10:43,346 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/printer/info
2023-11-19 14:10:43,535 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/printer/objects/query?configfile
2023-11-19 14:10:43,539 [screen.py:init_printer()] - {'configfile': {'config': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'control': 'pid', 'pid_kd': '86.991', 'pid_kp': '21.479', 'pid_ki': '1.326', 'min_temp': '0', 'max_temp': '300'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'control': 'pid', 'pid_kp': '64.440', 'pid_ki': '0.773', 'pid_kd': '1343.571', 'min_temp': '0', 'max_temp': '130'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'z_offset': '0', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 21.479, 'pid_ki': 1.326, 'pid_kd': 86.991, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 64.44, 'pid_ki': 0.773, 'pid_kd': 1343.571, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': 0.0, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-19 14:10:43,543 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1
2023-11-19 14:10:43,543 [printer.py:reinit()] - # Extruders: 1
2023-11-19 14:10:43,543 [printer.py:reinit()] - # Temperature devices: 1
2023-11-19 14:10:43,544 [printer.py:reinit()] - # Fans: 1
2023-11-19 14:10:43,544 [printer.py:reinit()] - # Output pins: 0
2023-11-19 14:10:43,544 [printer.py:reinit()] - # Leds: 0
2023-11-19 14:10:43,579 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/printer/gcode/help
2023-11-19 14:10:43,582 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-19 14:10:43,832 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-11-19 14:10:43,857 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/server/temperature_store
2023-11-19 14:10:43,883 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-11-19 14:10:43,914 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/server/config
2023-11-19 14:10:43,918 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-19 14:10:43,919 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-19 14:10:43,920 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-19 14:10:43,922 [screen.py:init_printer()] - Printer initialized
2023-11-19 14:10:43,923 [printer.py:change_state()] - Changing state from 'disconnected' to 'ready'
2023-11-19 14:10:43,924 [printer.py:change_state()] - Adding callback for state: ready
2023-11-19 14:10:43,936 [screen.py:_load_panel()] - Loading panel: main_menu
2023-11-19 14:10:44,093 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-19 14:10:44,109 [main_menu.py:add_device()] - Adding device: extruder
2023-11-19 14:10:44,122 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-19 14:10:44,185 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-19 14:18:27,044 [functions.py:log_start()] - --------------------KlipperScreen Log Start--------------------
2023-11-19 14:18:27,045 [functions.py:log_start()] - KlipperScreen Version: v0.3.6-85-gad3b935
2023-11-19 14:18:27,046 [functions.py:log_start()] - Python version: 3.9
2023-11-19 14:18:27,235 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-11-19 14:18:27,236 [config.py:__init__()] - Config path location: /home/biqu/KlipperScreen.conf
2023-11-19 14:18:27,276 [config.py:log_config()] -  ===== Config File =====
[main]

[printer SV06]
moonraker_host = localhost
moonraker_post = 7125
moonraker_api_key = [redacted]
=======================
2023-11-19 14:18:27,280 [config.py:__init__()] - ====== Saved Def ======

=======================
2023-11-19 14:18:27,281 [config.py:__init__()] - Configured printers: [
  {
    "SV06": {
      "moonraker_host": "localhost",
      "moonraker_port": "7125",
      "moonraker_api_key": "redacted"
    }
  }
]
2023-11-19 14:18:27,417 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-11-19 14:18:27,418 [config.py:install_language()] - Using system lang
2023-11-19 14:18:27,419 [config.py:install_language()] - Using lang en
2023-11-19 14:18:27,452 [screen.py:__init__()] - Screen resolution: 1024x600
2023-11-19 14:18:27,456 [KlippyGtk.py:__init__()] - Font size: 20.7 (medium)
2023-11-19 14:18:28,002 [screen.py:show_error_modal()] - Showing error modal: Invalid config file Option "moonraker_post" not recognized for section "[printer SV06]"


2023-11-19 14:18:28,133 [KlippyGtk.py:Dialog()] - Showing dialog Error (width=1028, height=600)
2023-11-19 14:18:28,149 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-11-19 14:18:28,168 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-11-19 14:18:28,183 [screen.py:initial_connection()] - Default printer: None
2023-11-19 14:18:28,183 [screen.py:connect_printer()] - Connecting to printer: SV06
2023-11-19 14:18:28,184 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-11-19 14:18:28,278 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-19 14:18:28,296 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-11-19 14:18:28,331 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/server/info
2023-11-19 14:18:28,355 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/access/oneshot_token
2023-11-19 14:18:28,357 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-11-19 14:18:28,377 [_logging.py:info()] - Websocket connected
2023-11-19 14:18:28,378 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-11-19 14:18:28,471 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/server/info
2023-11-19 14:18:28,494 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/server/info
2023-11-19 14:18:28,496 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'ready', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'authorization', 'octoprint_compat', 'history'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-19 14:18:28,523 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/server/webcams/list
2023-11-19 14:18:28,525 [printer.py:configure_cameras()] - Cameras: []
2023-11-19 14:18:28,551 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/printer/info
2023-11-19 14:18:28,785 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/printer/objects/query?configfile
2023-11-19 14:18:28,789 [screen.py:init_printer()] - {'configfile': {'config': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'control': 'pid', 'pid_kd': '86.991', 'pid_kp': '21.479', 'pid_ki': '1.326', 'min_temp': '0', 'max_temp': '300'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'control': 'pid', 'pid_kp': '64.440', 'pid_ki': '0.773', 'pid_kd': '1343.571', 'min_temp': '0', 'max_temp': '130'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'z_offset': '0', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 21.479, 'pid_ki': 1.326, 'pid_kd': 86.991, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 64.44, 'pid_ki': 0.773, 'pid_kd': 1343.571, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': 0.0, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-19 14:18:28,793 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1
2023-11-19 14:18:28,793 [printer.py:reinit()] - # Extruders: 1
2023-11-19 14:18:28,794 [printer.py:reinit()] - # Temperature devices: 1
2023-11-19 14:18:28,794 [printer.py:reinit()] - # Fans: 1
2023-11-19 14:18:28,794 [printer.py:reinit()] - # Output pins: 0
2023-11-19 14:18:28,794 [printer.py:reinit()] - # Leds: 0
2023-11-19 14:18:28,824 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/printer/gcode/help
2023-11-19 14:18:28,827 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-19 14:18:29,088 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-11-19 14:18:29,122 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/server/temperature_store
2023-11-19 14:18:29,145 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-11-19 14:18:29,169 [KlippyRest.py:_do_request()] - Sending request to http://localhost:7125/server/config
2023-11-19 14:18:29,171 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-19 14:18:29,172 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-19 14:18:29,173 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-19 14:18:29,174 [screen.py:init_printer()] - Printer initialized
2023-11-19 14:18:29,175 [printer.py:change_state()] - Changing state from 'disconnected' to 'ready'
2023-11-19 14:18:29,175 [printer.py:change_state()] - Adding callback for state: ready
2023-11-19 14:18:29,183 [screen.py:_load_panel()] - Loading panel: main_menu
2023-11-19 14:18:29,348 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-19 14:18:29,362 [main_menu.py:add_device()] - Adding device: extruder
2023-11-19 14:18:29,375 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-19 14:18:29,447 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-19 14:19:28,803 [functions.py:log_start()] - --------------------KlipperScreen Log Start--------------------
2023-11-19 14:19:28,804 [functions.py:log_start()] - KlipperScreen Version: v0.3.6-85-gad3b935
2023-11-19 14:19:28,804 [functions.py:log_start()] - Python version: 3.9
2023-11-19 14:19:28,994 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-11-19 14:19:28,999 [config.py:__init__()] - Config path location: /home/biqu/KlipperScreen/ks_includes/defaults.conf
2023-11-19 14:19:29,031 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-11-19 14:19:29,167 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-11-19 14:19:29,168 [config.py:install_language()] - Using system lang
2023-11-19 14:19:29,169 [config.py:install_language()] - Using lang en
2023-11-19 14:19:29,201 [screen.py:__init__()] - Screen resolution: 1024x600
2023-11-19 14:19:29,204 [KlippyGtk.py:__init__()] - Font size: 20.7 (medium)
2023-11-19 14:19:29,772 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-11-19 14:19:29,787 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-11-19 14:19:29,798 [screen.py:initial_connection()] - Default printer: None
2023-11-19 14:19:29,799 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-11-19 14:19:29,799 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-11-19 14:19:29,893 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-19 14:19:29,912 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-11-19 14:19:29,944 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-19 14:19:29,968 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-11-19 14:19:29,971 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-11-19 14:19:29,989 [_logging.py:info()] - Websocket connected
2023-11-19 14:19:29,990 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-11-19 14:19:30,071 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-19 14:19:30,095 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-19 14:19:30,097 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'ready', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'authorization', 'octoprint_compat', 'history'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-19 14:19:30,119 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-19 14:19:30,121 [printer.py:configure_cameras()] - Cameras: []
2023-11-19 14:19:30,149 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-19 14:19:30,236 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-19 14:19:30,240 [screen.py:init_printer()] - {'configfile': {'config': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'control': 'pid', 'pid_kd': '86.991', 'pid_kp': '21.479', 'pid_ki': '1.326', 'min_temp': '0', 'max_temp': '300'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'control': 'pid', 'pid_kp': '64.440', 'pid_ki': '0.773', 'pid_kd': '1343.571', 'min_temp': '0', 'max_temp': '130'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'z_offset': '0', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 21.479, 'pid_ki': 1.326, 'pid_kd': 86.991, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 64.44, 'pid_ki': 0.773, 'pid_kd': 1343.571, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': 0.0, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-19 14:19:30,244 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1
2023-11-19 14:19:30,244 [printer.py:reinit()] - # Extruders: 1
2023-11-19 14:19:30,244 [printer.py:reinit()] - # Temperature devices: 1
2023-11-19 14:19:30,245 [printer.py:reinit()] - # Fans: 1
2023-11-19 14:19:30,245 [printer.py:reinit()] - # Output pins: 0
2023-11-19 14:19:30,245 [printer.py:reinit()] - # Leds: 0
2023-11-19 14:19:30,273 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-19 14:19:30,276 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-19 14:19:30,539 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-11-19 14:19:30,579 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-19 14:19:30,601 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-11-19 14:19:30,627 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-19 14:19:30,629 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-19 14:19:30,630 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-19 14:19:30,631 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-19 14:19:30,632 [screen.py:init_printer()] - Printer initialized
2023-11-19 14:19:30,633 [printer.py:change_state()] - Changing state from 'disconnected' to 'ready'
2023-11-19 14:19:30,633 [printer.py:change_state()] - Adding callback for state: ready
2023-11-19 14:19:30,642 [screen.py:_load_panel()] - Loading panel: main_menu
2023-11-19 14:19:30,801 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-19 14:19:30,815 [main_menu.py:add_device()] - Adding device: extruder
2023-11-19 14:19:30,828 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-19 14:19:30,893 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-19 14:19:43,133 [screen.py:_load_panel()] - Loading panel: move
2023-11-19 14:19:43,299 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > move
2023-11-19 14:19:44,899 [screen.py:_load_panel()] - Loading panel: menu
2023-11-19 14:19:45,108 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > move > menu
2023-11-19 14:19:45,135 [menu.py:arrangeMenuItems()] - X > homing quad_gantry_level
2023-11-19 14:19:45,142 [menu.py:arrangeMenuItems()] - X > homing Z-Tilt
2023-11-19 14:19:46,107 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G28'}
2023-11-19 14:20:10,627 [screen.py:_menu_go_back()] - #### Menu go back
2023-11-19 14:20:10,682 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > move
2023-11-19 14:20:18,843 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 Z+25 F600'}
2023-11-19 14:20:18,850 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-19 14:20:25,963 [move.py:change_distance()] - ### Distance 50
2023-11-19 14:20:26,811 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 Z+50 F600'}
2023-11-19 14:20:26,816 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-19 14:20:34,603 [screen.py:_menu_go_back()] - #### Menu go back
2023-11-19 14:20:34,642 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-19 14:20:38,347 [main_menu.py:toggle_visibility()] - Graph show False: extruder
2023-11-19 14:20:38,351 [config.py:save_user_config_options()] - Creating a new config file in /home/biqu/printer_data/config/KlipperScreen.conf
2023-11-19 14:20:51,699 [main_menu.py:verify_max_temp()] - 205/300
2023-11-19 14:20:51,699 [KlippyWebsocket.py:set_tool_temp()] - Sending set_tool_temp: M104 T0 S205
2023-11-19 14:25:29,402 [screen.py:_go_to_submenu()] - #### Go to submenu more
2023-11-19 14:25:29,403 [screen.py:_go_to_submenu()] - #### Menu __main
2023-11-19 14:25:29,414 [screen.py:_load_panel()] - Loading panel: menu
2023-11-19 14:25:29,982 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > more
2023-11-19 14:25:29,992 [menu.py:arrangeMenuItems()] - X > more bedlevel
2023-11-19 14:25:30,016 [menu.py:arrangeMenuItems()] - X > more retraction
2023-11-19 14:25:30,034 [menu.py:arrangeMenuItems()] - X > more led
2023-11-19 14:25:30,052 [menu.py:arrangeMenuItems()] - X > more pins
2023-11-19 14:25:30,062 [menu.py:arrangeMenuItems()] - X > more power
2023-11-19 14:25:30,072 [menu.py:arrangeMenuItems()] - X > more camera
2023-11-19 14:25:30,086 [menu.py:arrangeMenuItems()] - X > more input_shaper
2023-11-19 14:25:30,110 [menu.py:arrangeMenuItems()] - X > more spoolman
2023-11-19 14:25:40,724 [screen.py:_load_panel()] - Loading panel: console
2023-11-19 14:25:40,819 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > more > console
2023-11-19 14:26:04,571 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: 
2023-11-19 14:26:09,570 [screen.py:_menu_go_back()] - #### Menu go back
2023-11-19 14:26:09,618 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > more
2023-11-19 14:26:09,631 [menu.py:arrangeMenuItems()] - X > more bedlevel
2023-11-19 14:26:09,650 [menu.py:arrangeMenuItems()] - X > more retraction
2023-11-19 14:26:09,667 [menu.py:arrangeMenuItems()] - X > more led
2023-11-19 14:26:09,682 [menu.py:arrangeMenuItems()] - X > more pins
2023-11-19 14:26:09,691 [menu.py:arrangeMenuItems()] - X > more power
2023-11-19 14:26:09,698 [menu.py:arrangeMenuItems()] - X > more camera
2023-11-19 14:26:09,712 [menu.py:arrangeMenuItems()] - X > more input_shaper
2023-11-19 14:26:09,734 [menu.py:arrangeMenuItems()] - X > more spoolman
2023-11-19 14:26:11,530 [screen.py:_menu_go_back()] - #### Menu go back
2023-11-19 14:26:11,565 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-19 14:26:50,066 [printer.py:change_state()] - Changing state from 'ready' to 'shutdown'
2023-11-19 14:26:50,067 [printer.py:change_state()] - Adding callback for state: shutdown
2023-11-19 14:26:50,083 [screen.py:show_panel()] - Reinitializing panel
2023-11-19 14:26:50,175 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-19 14:26:55,688 [printer.py:change_state()] - Changing state from 'shutdown' to 'disconnected'
2023-11-19 14:26:55,689 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-19 14:26:55,691 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-19 14:26:55,694 [screen.py:show_panel()] - Reinitializing panel
2023-11-19 14:26:55,783 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-19 14:26:59,531 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-19 14:26:59,556 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-19 14:26:59,558 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'authorization', 'octoprint_compat', 'history'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-19 14:26:59,579 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-19 14:26:59,581 [printer.py:configure_cameras()] - Cameras: []
2023-11-19 14:26:59,606 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-19 14:26:59,639 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-19 14:26:59,643 [screen.py:init_printer()] - {'configfile': {'config': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'control': 'pid', 'pid_kd': '86.991', 'pid_kp': '21.479', 'pid_ki': '1.326', 'min_temp': '0', 'max_temp': '300'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'control': 'pid', 'pid_kp': '64.440', 'pid_ki': '0.773', 'pid_kd': '1343.571', 'min_temp': '0', 'max_temp': '130'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'z_offset': '0', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 21.479, 'pid_ki': 1.326, 'pid_kd': 86.991, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 64.44, 'pid_ki': 0.773, 'pid_kd': 1343.571, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': 0.0, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-19 14:26:59,647 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1
2023-11-19 14:26:59,648 [printer.py:reinit()] - # Extruders: 1
2023-11-19 14:26:59,649 [printer.py:reinit()] - # Temperature devices: 1
2023-11-19 14:26:59,649 [printer.py:reinit()] - # Fans: 1
2023-11-19 14:26:59,650 [printer.py:reinit()] - # Output pins: 0
2023-11-19 14:26:59,650 [printer.py:reinit()] - # Leds: 0
2023-11-19 14:26:59,677 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-19 14:26:59,681 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-19 14:26:59,934 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-11-19 14:26:59,983 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-19 14:26:59,997 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-11-19 14:27:00,025 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-19 14:27:00,028 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-19 14:27:00,029 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-19 14:27:00,029 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-19 14:27:00,031 [screen.py:init_printer()] - Printer initialized
2023-11-19 14:27:00,032 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-19 14:27:00,032 [printer.py:change_state()] - Adding callback for state: startup
2023-11-19 14:27:00,634 [printer.py:change_state()] - Changing state from 'startup' to 'error'
2023-11-19 14:27:00,634 [printer.py:change_state()] - Adding callback for state: error
2023-11-19 14:27:00,639 [screen.py:show_panel()] - Reinitializing panel
2023-11-19 14:27:00,728 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-19 14:27:04,442 [printer.py:change_state()] - Changing state from 'error' to 'disconnected'
2023-11-19 14:27:04,442 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-19 14:27:04,444 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-19 14:27:04,447 [screen.py:show_panel()] - Reinitializing panel
2023-11-19 14:27:04,542 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-19 14:27:07,531 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-19 14:27:07,563 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-19 14:27:07,566 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'authorization', 'octoprint_compat', 'history'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-19 14:27:07,591 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-19 14:27:07,593 [printer.py:configure_cameras()] - Cameras: []
2023-11-19 14:27:08,092 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-19 14:27:08,128 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-19 14:27:08,132 [screen.py:init_printer()] - {'configfile': {'config': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'control': 'pid', 'pid_kd': '86.991', 'pid_kp': '21.479', 'pid_ki': '1.326', 'min_temp': '0', 'max_temp': '300'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'control': 'pid', 'pid_kp': '64.440', 'pid_ki': '0.773', 'pid_kd': '1343.571', 'min_temp': '0', 'max_temp': '130'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'z_offset': '0', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 21.479, 'pid_ki': 1.326, 'pid_kd': 86.991, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 64.44, 'pid_ki': 0.773, 'pid_kd': 1343.571, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': 0.0, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-19 14:27:08,136 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1
2023-11-19 14:27:08,137 [printer.py:reinit()] - # Extruders: 1
2023-11-19 14:27:08,137 [printer.py:reinit()] - # Temperature devices: 1
2023-11-19 14:27:08,138 [printer.py:reinit()] - # Fans: 1
2023-11-19 14:27:08,138 [printer.py:reinit()] - # Output pins: 0
2023-11-19 14:27:08,138 [printer.py:reinit()] - # Leds: 0
2023-11-19 14:27:08,164 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-19 14:27:08,167 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-19 14:27:08,425 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-11-19 14:27:08,469 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-19 14:27:08,482 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-11-19 14:27:08,507 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-19 14:27:08,510 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-19 14:27:08,511 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-19 14:27:08,511 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-19 14:27:08,513 [screen.py:init_printer()] - Printer initialized
2023-11-19 14:27:08,514 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-19 14:27:08,515 [printer.py:change_state()] - Adding callback for state: startup
2023-11-19 14:27:09,904 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-19 14:27:09,905 [printer.py:change_state()] - Adding callback for state: ready
2023-11-19 14:27:09,913 [screen.py:show_panel()] - Reinitializing panel
2023-11-19 14:27:10,087 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-19 14:27:10,104 [main_menu.py:add_device()] - Adding device: extruder
2023-11-19 14:27:10,119 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-19 14:27:10,197 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-19 14:35:01,557 [KlippyGtk.py:Dialog()] - Showing dialog KlipperScreen (width=1024, height=600)
2023-11-19 14:35:52,731 [printer.py:change_state()] - Changing state from 'ready' to 'disconnected'
2023-11-19 14:35:52,732 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-19 14:35:52,735 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-19 14:35:52,743 [KlippyGtk.py:remove_dialog()] - Removing Dialog
2023-11-19 14:35:52,744 [screen.py:show_panel()] - Reinitializing panel
2023-11-19 14:35:52,841 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-19 14:35:56,535 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-19 14:35:56,559 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-19 14:35:56,562 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'authorization', 'octoprint_compat', 'history'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-19 14:35:56,582 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-19 14:35:56,584 [printer.py:configure_cameras()] - Cameras: []
2023-11-19 14:35:56,615 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-19 14:35:56,648 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-19 14:35:56,652 [screen.py:init_printer()] - {'configfile': {'config': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '23.940', 'pid_ki': '1.629', 'pid_kd': '87.981'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'control': 'pid', 'pid_kp': '64.440', 'pid_ki': '0.773', 'pid_kd': '1343.571', 'min_temp': '0', 'max_temp': '130'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'z_offset': '0', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 23.94, 'pid_ki': 1.629, 'pid_kd': 87.981, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 64.44, 'pid_ki': 0.773, 'pid_kd': 1343.571, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': 0.0, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-19 14:35:56,656 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1
2023-11-19 14:35:56,657 [printer.py:reinit()] - # Extruders: 1
2023-11-19 14:35:56,658 [printer.py:reinit()] - # Temperature devices: 1
2023-11-19 14:35:56,658 [printer.py:reinit()] - # Fans: 1
2023-11-19 14:35:56,658 [printer.py:reinit()] - # Output pins: 0
2023-11-19 14:35:56,659 [printer.py:reinit()] - # Leds: 0
2023-11-19 14:35:56,698 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-19 14:35:56,701 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-19 14:35:56,947 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-11-19 14:35:56,993 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-19 14:35:57,003 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-11-19 14:35:57,028 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-19 14:35:57,030 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-19 14:35:57,031 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-19 14:35:57,032 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-19 14:35:57,033 [screen.py:init_printer()] - Printer initialized
2023-11-19 14:35:57,034 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-19 14:35:57,035 [printer.py:change_state()] - Adding callback for state: startup
2023-11-19 14:35:58,400 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-19 14:35:58,400 [printer.py:change_state()] - Adding callback for state: ready
2023-11-19 14:35:58,409 [screen.py:show_panel()] - Reinitializing panel
2023-11-19 14:35:58,560 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-19 14:35:58,574 [main_menu.py:add_device()] - Adding device: extruder
2023-11-19 14:35:58,586 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-19 14:35:58,660 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-19 14:48:54,558 [KlippyGtk.py:remove_dialog()] - Cannot remove dialog <Gtk.Dialog object at 0xffff6cf25c00 (GtkDialog at 0x21f48b20)>
2023-11-19 14:48:54,587 [KlippyGtk.py:Dialog()] - Showing dialog KlipperScreen (width=1024, height=600)
2023-11-19 14:50:45,367 [printer.py:change_state()] - Changing state from 'ready' to 'disconnected'
2023-11-19 14:50:45,368 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-19 14:50:45,370 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-19 14:50:45,376 [KlippyGtk.py:remove_dialog()] - Removing Dialog
2023-11-19 14:50:45,378 [screen.py:show_panel()] - Reinitializing panel
2023-11-19 14:50:45,473 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-19 14:50:48,540 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-19 14:50:48,571 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-19 14:50:48,575 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'authorization', 'octoprint_compat', 'history'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-19 14:50:48,601 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-19 14:50:48,604 [printer.py:configure_cameras()] - Cameras: []
2023-11-19 14:50:49,223 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-19 14:50:49,264 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-19 14:50:49,268 [screen.py:init_printer()] - {'configfile': {'config': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '23.940', 'pid_ki': '1.629', 'pid_kd': '87.981'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'min_temp': '0', 'max_temp': '130', 'control': 'pid', 'pid_kp': '69.445', 'pid_ki': '1.146', 'pid_kd': '1052.087'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'z_offset': '0', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 23.94, 'pid_ki': 1.629, 'pid_kd': 87.981, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 69.445, 'pid_ki': 1.146, 'pid_kd': 1052.087, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': 0.0, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-19 14:50:49,274 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1
2023-11-19 14:50:49,274 [printer.py:reinit()] - # Extruders: 1
2023-11-19 14:50:49,275 [printer.py:reinit()] - # Temperature devices: 1
2023-11-19 14:50:49,275 [printer.py:reinit()] - # Fans: 1
2023-11-19 14:50:49,276 [printer.py:reinit()] - # Output pins: 0
2023-11-19 14:50:49,276 [printer.py:reinit()] - # Leds: 0
2023-11-19 14:50:49,308 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-19 14:50:49,312 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-19 14:50:49,547 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-11-19 14:50:49,607 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-19 14:50:49,616 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-11-19 14:50:49,640 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-19 14:50:49,644 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-19 14:50:49,645 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-19 14:50:49,645 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-19 14:50:49,647 [screen.py:init_printer()] - Printer initialized
2023-11-19 14:50:49,648 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-19 14:50:49,648 [printer.py:change_state()] - Adding callback for state: startup
2023-11-19 14:50:51,008 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-19 14:50:51,009 [printer.py:change_state()] - Adding callback for state: ready
2023-11-19 14:50:51,016 [screen.py:show_panel()] - Reinitializing panel
2023-11-19 14:50:51,175 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-19 14:50:51,189 [main_menu.py:add_device()] - Adding device: extruder
2023-11-19 14:50:51,202 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-19 14:50:51,266 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-19 15:26:12,509 [screen.py:show_screensaver()] - Showing Screensaver
2023-11-19 15:43:40,961 [printer.py:change_state()] - Changing state from 'ready' to 'disconnected'
2023-11-19 15:43:40,962 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-19 15:43:40,967 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-19 15:43:40,968 [screen.py:close_screensaver()] - Closing Screensaver
2023-11-19 15:43:41,000 [screen.py:wake_screen()] - Screen wake up
2023-11-19 15:43:41,063 [screen.py:show_panel()] - Reinitializing panel
2023-11-19 15:43:41,152 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-19 15:43:44,528 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-19 15:43:44,549 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-19 15:43:44,552 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'authorization', 'octoprint_compat', 'history'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-19 15:43:44,572 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-19 15:43:44,574 [printer.py:configure_cameras()] - Cameras: []
2023-11-19 15:43:44,575 [screen.py:init_printer()] - Klipper not connected
2023-11-19 15:43:47,530 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-19 15:43:47,551 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-19 15:43:47,553 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'authorization', 'octoprint_compat', 'history'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-19 15:43:47,573 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-19 15:43:47,576 [printer.py:configure_cameras()] - Cameras: []
2023-11-19 15:43:47,576 [screen.py:init_printer()] - Klipper not connected
2023-11-19 15:43:50,530 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-19 15:43:50,555 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-19 15:43:50,557 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'authorization', 'octoprint_compat', 'history'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-19 15:43:50,580 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-19 15:43:50,582 [printer.py:configure_cameras()] - Cameras: []
2023-11-19 15:43:50,583 [screen.py:init_printer()] - Klipper not connected
2023-11-19 15:43:53,529 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-19 15:43:53,551 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-19 15:43:53,554 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'authorization', 'octoprint_compat', 'history'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-19 15:43:53,575 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-19 15:43:53,577 [printer.py:configure_cameras()] - Cameras: []
2023-11-19 15:43:53,577 [screen.py:init_printer()] - Klipper not connected
2023-11-19 15:43:56,530 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-19 15:43:56,554 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-19 15:43:56,557 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'authorization', 'octoprint_compat', 'history'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-19 15:43:56,580 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-19 15:43:56,582 [printer.py:configure_cameras()] - Cameras: []
2023-11-19 15:43:56,582 [screen.py:init_printer()] - Klipper not connected
2023-11-19 15:44:32,460 [screen.py:_websocket_callback()] - Still not initialized
2023-11-19 15:49:35,303 [screen.py:_websocket_callback()] - Still not initialized
2023-11-19 15:51:46,542 [screen.py:_websocket_callback()] - Still not initialized
2023-11-19 16:34:48,300 [screen.py:_websocket_callback()] - Still not initialized
2023-11-20 11:28:12,398 [functions.py:log_start()] - --------------------KlipperScreen Log Start--------------------
2023-11-20 11:28:12,398 [functions.py:log_start()] - KlipperScreen Version: v0.3.6-85-gad3b935
2023-11-20 11:28:12,399 [functions.py:log_start()] - Python version: 3.9
2023-11-20 11:28:12,700 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-11-20 11:28:12,703 [config.py:__init__()] - Config path location: /home/biqu/printer_data/config/KlipperScreen.conf
2023-11-20 11:28:12,743 [config.py:log_config()] -  ===== Config File =====

=======================
2023-11-20 11:28:12,748 [config.py:__init__()] - ====== Saved Def ======

[graph Printer]
extruder = False

=======================
2023-11-20 11:28:12,750 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-11-20 11:28:12,895 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-11-20 11:28:12,896 [config.py:install_language()] - Using system lang
2023-11-20 11:28:12,897 [config.py:install_language()] - Using lang en
2023-11-20 11:28:12,938 [screen.py:__init__()] - Screen resolution: 1024x600
2023-11-20 11:28:12,942 [KlippyGtk.py:__init__()] - Font size: 20.7 (medium)
2023-11-20 11:28:14,795 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-11-20 11:28:14,809 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-11-20 11:28:14,821 [screen.py:initial_connection()] - Default printer: None
2023-11-20 11:28:14,821 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-11-20 11:28:14,822 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-11-20 11:28:14,917 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-20 11:28:14,935 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-11-20 11:28:14,970 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-20 11:28:14,994 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-11-20 11:28:14,996 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-11-20 11:28:15,013 [_logging.py:info()] - Websocket connected
2023-11-20 11:28:15,014 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-11-20 11:28:15,092 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-20 11:28:15,114 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-20 11:28:15,116 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'ready', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'history', 'update_manager', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-20 11:28:15,137 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-20 11:28:15,140 [printer.py:configure_cameras()] - Cameras: []
2023-11-20 11:28:15,164 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-20 11:28:15,357 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-20 11:28:15,361 [screen.py:init_printer()] - {'configfile': {'config': {'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': '2.', 'verbose': 'True'}, 'gcode_macro HELLO_WORLD': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world'}, 'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '23.940', 'pid_ki': '1.629', 'pid_kd': '87.981'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'min_temp': '0', 'max_temp': '130', 'control': 'pid', 'pid_kp': '69.445', 'pid_ki': '1.146', 'pid_kd': '1052.087'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'z_offset': '0', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': '90.0', 'verbose': 'True'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': 2.0, 'verbose': True}, 'gcode_macro hello_world': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world', 'description': 'G-Code macro'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 23.94, 'pid_ki': 1.629, 'pid_kd': 87.981, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 69.445, 'pid_ki': 1.146, 'pid_kd': 1052.087, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': 0.0, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script', 'description': 'G-Code macro'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': 90.0, 'verbose': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-20 11:28:15,364 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1-dirty
2023-11-20 11:28:15,365 [printer.py:reinit()] - # Extruders: 1
2023-11-20 11:28:15,365 [printer.py:reinit()] - # Temperature devices: 1
2023-11-20 11:28:15,365 [printer.py:reinit()] - # Fans: 1
2023-11-20 11:28:15,366 [printer.py:reinit()] - # Output pins: 0
2023-11-20 11:28:15,366 [printer.py:reinit()] - # Leds: 0
2023-11-20 11:28:15,394 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-20 11:28:15,397 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-20 11:28:15,661 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-11-20 11:28:15,687 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-20 11:28:15,712 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-11-20 11:28:15,735 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-20 11:28:15,738 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-20 11:28:15,738 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-20 11:28:15,739 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-20 11:28:15,740 [screen.py:init_printer()] - Printer initialized
2023-11-20 11:28:15,741 [printer.py:change_state()] - Changing state from 'disconnected' to 'ready'
2023-11-20 11:28:15,742 [printer.py:change_state()] - Adding callback for state: ready
2023-11-20 11:28:15,750 [screen.py:_load_panel()] - Loading panel: main_menu
2023-11-20 11:28:15,912 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-20 11:28:15,927 [main_menu.py:add_device()] - Adding device: extruder
2023-11-20 11:28:15,940 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-20 11:28:16,005 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-20 11:42:10,339 [screen.py:_load_panel()] - Loading panel: move
2023-11-20 11:42:10,506 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > move
2023-11-20 11:42:11,911 [screen.py:_load_panel()] - Loading panel: menu
2023-11-20 11:42:12,149 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > move > menu
2023-11-20 11:42:12,180 [menu.py:arrangeMenuItems()] - X > homing quad_gantry_level
2023-11-20 11:42:12,189 [menu.py:arrangeMenuItems()] - X > homing Z-Tilt
2023-11-20 11:42:13,321 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G28'}
2023-11-20 11:42:37,952 [screen.py:_menu_go_back()] - #### Menu go back
2023-11-20 11:42:38,000 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > move
2023-11-20 11:42:39,952 [screen.py:_menu_go_back()] - #### Menu go back
2023-11-20 11:42:40,006 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-20 11:42:48,363 [screen.py:_load_panel()] - Loading panel: gcode_macros
2023-11-20 11:42:48,433 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > gcode_macros
2023-11-20 11:42:54,184 [screen.py:_menu_go_back()] - #### Menu go back
2023-11-20 11:42:54,231 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-20 11:42:56,385 [screen.py:_go_to_submenu()] - #### Go to submenu more
2023-11-20 11:42:56,385 [screen.py:_go_to_submenu()] - #### Menu __main
2023-11-20 11:42:56,398 [screen.py:_load_panel()] - Loading panel: menu
2023-11-20 11:42:56,925 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > more
2023-11-20 11:42:56,935 [menu.py:arrangeMenuItems()] - X > more bedlevel
2023-11-20 11:42:56,955 [menu.py:arrangeMenuItems()] - X > more retraction
2023-11-20 11:42:56,969 [menu.py:arrangeMenuItems()] - X > more led
2023-11-20 11:42:56,984 [menu.py:arrangeMenuItems()] - X > more pins
2023-11-20 11:42:56,992 [menu.py:arrangeMenuItems()] - X > more power
2023-11-20 11:42:56,999 [menu.py:arrangeMenuItems()] - X > more camera
2023-11-20 11:42:57,013 [menu.py:arrangeMenuItems()] - X > more input_shaper
2023-11-20 11:42:57,035 [menu.py:arrangeMenuItems()] - X > more spoolman
2023-11-20 11:42:59,362 [screen.py:_load_panel()] - Loading panel: console
2023-11-20 11:42:59,462 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > more > console
2023-11-20 11:43:13,123 [keyboard.py:__init__()] - Keyboard en
2023-11-20 11:43:13,594 [screen.py:update_size()] - Size changed: 1024x600
2023-11-20 11:44:08,731 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: probe_CALIBRATE
2023-11-20 11:44:12,295 [screen.py:_load_panel()] - Loading panel: zcalibrate
2023-11-20 11:44:12,325 [printer.py:get_probe()] - Probe type: probe
2023-11-20 11:44:12,325 [zcalibrate.py:__init__()] - Z offset: 0.0
2023-11-20 11:44:12,382 [zcalibrate.py:__init__()] - Available functions for calibration: ['probe']
2023-11-20 11:44:12,426 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > more > console > zcalibrate
2023-11-20 11:44:54,360 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: TESTZ Z=-1
2023-11-20 11:44:55,760 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: TESTZ Z=-1
2023-11-20 11:44:56,664 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: TESTZ Z=-1
2023-11-20 11:44:59,720 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: TESTZ Z=-1
2023-11-20 11:45:02,376 [zcalibrate.py:change_distance()] - ### Distance .05
2023-11-20 11:45:04,392 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: TESTZ Z=-.05
2023-11-20 11:45:04,528 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: TESTZ Z=-.05
2023-11-20 11:45:06,521 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: TESTZ Z=-.05
2023-11-20 11:45:11,104 [zcalibrate.py:change_distance()] - ### Distance .1
2023-11-20 11:45:13,320 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: TESTZ Z=-.1
2023-11-20 11:45:19,184 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: TESTZ Z=-.1
2023-11-20 11:45:29,329 [zcalibrate.py:change_distance()] - ### Distance .01
2023-11-20 11:45:31,680 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: TESTZ Z=-.01
2023-11-20 11:45:32,160 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: TESTZ Z=-.01
2023-11-20 11:45:32,768 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: TESTZ Z=-.01
2023-11-20 11:45:36,184 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: TESTZ Z=+.01
2023-11-20 11:45:38,745 [zcalibrate.py:change_distance()] - ### Distance 1
2023-11-20 11:45:39,904 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: TESTZ Z=+1
2023-11-20 11:45:45,280 [zcalibrate.py:change_distance()] - ### Distance .5
2023-11-20 11:45:51,776 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: TESTZ Z=-.5
2023-11-20 11:45:56,370 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: TESTZ Z=-.5
2023-11-20 11:45:59,192 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: TESTZ Z=-.5
2023-11-20 11:46:01,600 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: TESTZ Z=+.5
2023-11-20 11:46:04,874 [zcalibrate.py:change_distance()] - ### Distance .1
2023-11-20 11:46:06,736 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: TESTZ Z=-.1
2023-11-20 11:46:09,504 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: TESTZ Z=-.1
2023-11-20 11:46:10,552 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: TESTZ Z=-.1
2023-11-20 11:46:14,032 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: TESTZ Z=-.1
2023-11-20 11:46:19,248 [zcalibrate.py:accept()] - Accepting Z position
2023-11-20 11:46:19,248 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: ACCEPT
2023-11-20 11:46:19,300 [KlippyGtk.py:Dialog()] - Showing dialog KlipperScreen (width=1024, height=600)
2023-11-20 11:46:25,355 [KlippyGtk.py:remove_dialog()] - Removing Dialog
2023-11-20 11:46:25,356 [screen.py:_send_action()] - printer.gcode.script: {'script': 'SAVE_CONFIG'}
2023-11-20 11:46:26,444 [printer.py:change_state()] - Changing state from 'ready' to 'disconnected'
2023-11-20 11:46:26,444 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-20 11:46:26,447 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-20 11:46:26,450 [screen.py:show_panel()] - Reinitializing panel
2023-11-20 11:46:26,539 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-20 11:46:30,310 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-20 11:46:30,337 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-20 11:46:30,339 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'history', 'update_manager', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-20 11:46:30,360 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-20 11:46:30,362 [printer.py:configure_cameras()] - Cameras: []
2023-11-20 11:46:30,386 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-20 11:46:30,421 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-20 11:46:30,425 [screen.py:init_printer()] - {'configfile': {'config': {'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': '2.', 'verbose': 'True'}, 'gcode_macro HELLO_WORLD': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world'}, 'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '23.940', 'pid_ki': '1.629', 'pid_kd': '87.981'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'min_temp': '0', 'max_temp': '130', 'control': 'pid', 'pid_kp': '69.445', 'pid_ki': '1.146', 'pid_kd': '1052.087'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5', 'z_offset': '-0.230'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': '90.0', 'verbose': 'True'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': 2.0, 'verbose': True}, 'gcode_macro hello_world': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world', 'description': 'G-Code macro'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 23.94, 'pid_ki': 1.629, 'pid_kd': 87.981, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 69.445, 'pid_ki': 1.146, 'pid_kd': 1052.087, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': -0.23, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script', 'description': 'G-Code macro'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': 90.0, 'verbose': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-20 11:46:30,429 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1-dirty
2023-11-20 11:46:30,430 [printer.py:reinit()] - # Extruders: 1
2023-11-20 11:46:30,430 [printer.py:reinit()] - # Temperature devices: 1
2023-11-20 11:46:30,431 [printer.py:reinit()] - # Fans: 1
2023-11-20 11:46:30,431 [printer.py:reinit()] - # Output pins: 0
2023-11-20 11:46:30,431 [printer.py:reinit()] - # Leds: 0
2023-11-20 11:46:30,458 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-20 11:46:30,461 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-20 11:46:30,710 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-11-20 11:46:30,766 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-20 11:46:30,778 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-11-20 11:46:30,803 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-20 11:46:30,806 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-20 11:46:30,807 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-20 11:46:30,807 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-20 11:46:30,808 [screen.py:init_printer()] - Printer initialized
2023-11-20 11:46:30,810 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-20 11:46:30,810 [printer.py:change_state()] - Adding callback for state: startup
2023-11-20 11:46:32,176 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-20 11:46:32,177 [printer.py:change_state()] - Adding callback for state: ready
2023-11-20 11:46:32,185 [screen.py:show_panel()] - Reinitializing panel
2023-11-20 11:46:32,342 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-20 11:46:32,356 [main_menu.py:add_device()] - Adding device: extruder
2023-11-20 11:46:32,369 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-20 11:46:32,434 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-20 11:46:35,482 [screen.py:show_panel()] - Reinitializing panel
2023-11-20 11:46:35,643 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > move
2023-11-20 11:46:36,869 [screen.py:show_panel()] - Reinitializing panel
2023-11-20 11:46:37,089 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > move > menu
2023-11-20 11:46:37,122 [menu.py:arrangeMenuItems()] - X > homing quad_gantry_level
2023-11-20 11:46:37,129 [menu.py:arrangeMenuItems()] - X > homing Z-Tilt
2023-11-20 11:46:39,416 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G28'}
2023-11-20 12:00:30,112 [printer.py:change_state()] - Changing state from 'ready' to 'disconnected'
2023-11-20 12:00:30,113 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-20 12:00:30,115 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-20 12:00:30,119 [screen.py:show_panel()] - Reinitializing panel
2023-11-20 12:00:30,208 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-20 12:00:33,310 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-20 12:00:33,333 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-20 12:00:33,335 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'history', 'update_manager', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-20 12:00:33,358 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-20 12:00:33,360 [printer.py:configure_cameras()] - Cameras: []
2023-11-20 12:00:33,954 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-20 12:00:33,991 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-20 12:00:33,995 [screen.py:init_printer()] - {'configfile': {'config': {'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': '2.', 'verbose': 'True'}, 'gcode_macro HELLO_WORLD': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world'}, 'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '23.940', 'pid_ki': '1.629', 'pid_kd': '87.981'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'min_temp': '0', 'max_temp': '130', 'control': 'pid', 'pid_kp': '69.445', 'pid_ki': '1.146', 'pid_kd': '1052.087'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5', 'z_offset': '-0.230'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': '90.0', 'verbose': 'True'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': 2.0, 'verbose': True}, 'gcode_macro hello_world': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world', 'description': 'G-Code macro'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 23.94, 'pid_ki': 1.629, 'pid_kd': 87.981, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 69.445, 'pid_ki': 1.146, 'pid_kd': 1052.087, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': -0.23, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script', 'description': 'G-Code macro'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': 90.0, 'verbose': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-20 12:00:34,000 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1-dirty
2023-11-20 12:00:34,001 [printer.py:reinit()] - # Extruders: 1
2023-11-20 12:00:34,001 [printer.py:reinit()] - # Temperature devices: 1
2023-11-20 12:00:34,002 [printer.py:reinit()] - # Fans: 1
2023-11-20 12:00:34,002 [printer.py:reinit()] - # Output pins: 0
2023-11-20 12:00:34,003 [printer.py:reinit()] - # Leds: 0
2023-11-20 12:00:34,030 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-20 12:00:34,033 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-20 12:00:34,293 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-11-20 12:00:34,348 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-20 12:00:34,358 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-11-20 12:00:34,385 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-20 12:00:34,387 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-20 12:00:34,389 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-20 12:00:34,389 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-20 12:00:34,390 [screen.py:init_printer()] - Printer initialized
2023-11-20 12:00:34,391 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-20 12:00:34,392 [printer.py:change_state()] - Adding callback for state: startup
2023-11-20 12:00:35,740 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-20 12:00:35,741 [printer.py:change_state()] - Adding callback for state: ready
2023-11-20 12:00:35,750 [screen.py:show_panel()] - Reinitializing panel
2023-11-20 12:00:35,926 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-20 12:00:35,941 [main_menu.py:add_device()] - Adding device: extruder
2023-11-20 12:00:35,953 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-20 12:00:36,020 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-20 14:10:43,617 [functions.py:log_start()] - --------------------KlipperScreen Log Start--------------------
2023-11-20 14:10:43,618 [functions.py:log_start()] - KlipperScreen Version: v0.3.6-85-gad3b935
2023-11-20 14:10:43,619 [functions.py:log_start()] - Python version: 3.9
2023-11-20 14:10:44,040 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-11-20 14:10:44,043 [config.py:__init__()] - Config path location: /home/biqu/printer_data/config/KlipperScreen.conf
2023-11-20 14:10:44,101 [config.py:log_config()] -  ===== Config File =====

=======================
2023-11-20 14:10:44,106 [config.py:__init__()] - ====== Saved Def ======

[graph Printer]
extruder = False

=======================
2023-11-20 14:10:44,109 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-11-20 14:10:44,249 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-11-20 14:10:44,250 [config.py:install_language()] - Using system lang
2023-11-20 14:10:44,251 [config.py:install_language()] - Using lang en
2023-11-20 14:10:44,292 [screen.py:__init__()] - Screen resolution: 1024x600
2023-11-20 14:10:44,295 [KlippyGtk.py:__init__()] - Font size: 20.7 (medium)
2023-11-20 14:10:47,142 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-11-20 14:10:47,165 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-11-20 14:10:47,180 [screen.py:initial_connection()] - Default printer: None
2023-11-20 14:10:47,181 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-11-20 14:10:47,182 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-11-20 14:10:47,301 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-20 14:10:47,332 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-11-20 14:10:47,388 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-20 14:10:47,418 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-11-20 14:10:47,421 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-11-20 14:10:47,440 [_logging.py:info()] - Websocket connected
2023-11-20 14:10:47,441 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-11-20 14:10:47,624 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-20 14:10:47,647 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-20 14:10:47,650 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'authorization', 'history', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-20 14:10:47,673 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-20 14:10:47,675 [printer.py:configure_cameras()] - Cameras: []
2023-11-20 14:10:47,675 [screen.py:init_printer()] - Klipper not connected
2023-11-20 14:10:51,193 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-20 14:10:51,216 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-20 14:10:51,219 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'authorization', 'history', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-20 14:10:51,240 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-20 14:10:51,242 [printer.py:configure_cameras()] - Cameras: []
2023-11-20 14:10:51,243 [screen.py:init_printer()] - Klipper not connected
2023-11-20 14:10:54,197 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-20 14:10:54,223 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-20 14:10:54,226 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'authorization', 'history', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-20 14:10:54,253 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-20 14:10:54,255 [printer.py:configure_cameras()] - Cameras: []
2023-11-20 14:10:54,303 [KlippyRest.py:_do_request()] - 404 Client Error>>Not Found for url>>http://127.0.0.1:7125/printer/info
2023-11-20 14:10:57,198 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-20 14:10:57,228 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-20 14:10:57,230 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'authorization', 'history', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-20 14:10:57,252 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-20 14:10:57,255 [printer.py:configure_cameras()] - Cameras: []
2023-11-20 14:10:57,279 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-20 14:10:57,314 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-20 14:10:57,318 [screen.py:init_printer()] - {'configfile': {'config': {'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': '2.', 'verbose': 'True'}, 'gcode_macro HELLO_WORLD': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world'}, 'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '23.940', 'pid_ki': '1.629', 'pid_kd': '87.981'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'min_temp': '0', 'max_temp': '130', 'control': 'pid', 'pid_kp': '69.445', 'pid_ki': '1.146', 'pid_kd': '1052.087'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5', 'z_offset': '-0.230'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': '90.0', 'verbose': 'True'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': 2.0, 'verbose': True}, 'gcode_macro hello_world': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world', 'description': 'G-Code macro'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 23.94, 'pid_ki': 1.629, 'pid_kd': 87.981, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 69.445, 'pid_ki': 1.146, 'pid_kd': 1052.087, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': -0.23, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script', 'description': 'G-Code macro'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': 90.0, 'verbose': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-20 14:10:57,322 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1-dirty
2023-11-20 14:10:57,323 [printer.py:reinit()] - # Extruders: 1
2023-11-20 14:10:57,323 [printer.py:reinit()] - # Temperature devices: 1
2023-11-20 14:10:57,323 [printer.py:reinit()] - # Fans: 1
2023-11-20 14:10:57,324 [printer.py:reinit()] - # Output pins: 0
2023-11-20 14:10:57,324 [printer.py:reinit()] - # Leds: 0
2023-11-20 14:10:57,355 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-20 14:10:57,358 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-20 14:10:57,608 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-11-20 14:10:57,641 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-20 14:10:57,643 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-11-20 14:10:57,644 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-20 14:10:57,645 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-20 14:10:57,647 [screen.py:init_printer()] - Printer initialized
2023-11-20 14:10:57,648 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-20 14:10:57,649 [printer.py:change_state()] - Adding callback for state: startup
2023-11-20 14:10:59,070 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-20 14:10:59,071 [printer.py:change_state()] - Adding callback for state: ready
2023-11-20 14:10:59,077 [screen.py:_load_panel()] - Loading panel: main_menu
2023-11-20 14:10:59,248 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-20 14:10:59,263 [main_menu.py:add_device()] - Adding device: extruder
2023-11-20 14:10:59,276 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-20 14:10:59,350 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-20 14:10:59,353 [main_menu.py:update_graph_visibility()] - Could not create graph tempstore: []
2023-11-20 14:11:03,201 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-20 14:11:03,235 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-11-20 14:11:03,260 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-20 14:11:03,263 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-20 15:00:45,474 [printer.py:change_state()] - Changing state from 'ready' to 'disconnected'
2023-11-20 15:00:45,475 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-20 15:00:45,477 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-20 15:00:45,481 [screen.py:show_panel()] - Reinitializing panel
2023-11-20 15:00:45,571 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-20 15:00:49,192 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-20 15:00:49,213 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-20 15:00:49,216 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'authorization', 'history', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-20 15:00:49,236 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-20 15:00:49,239 [printer.py:configure_cameras()] - Cameras: []
2023-11-20 15:00:49,263 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-20 15:00:49,299 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-20 15:00:49,303 [screen.py:init_printer()] - {'configfile': {'config': {'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': '2.', 'verbose': 'True'}, 'gcode_macro HELLO_WORLD': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world'}, 'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '23.940', 'pid_ki': '1.629', 'pid_kd': '87.981'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'min_temp': '0', 'max_temp': '130', 'control': 'pid', 'pid_kp': '69.445', 'pid_ki': '1.146', 'pid_kd': '1052.087'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5', 'z_offset': '-0.230'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': '90.0', 'verbose': 'True'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': 2.0, 'verbose': True}, 'gcode_macro hello_world': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world', 'description': 'G-Code macro'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 23.94, 'pid_ki': 1.629, 'pid_kd': 87.981, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 69.445, 'pid_ki': 1.146, 'pid_kd': 1052.087, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': -0.23, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script', 'description': 'G-Code macro'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': 90.0, 'verbose': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-20 15:00:49,307 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1-dirty
2023-11-20 15:00:49,308 [printer.py:reinit()] - # Extruders: 1
2023-11-20 15:00:49,309 [printer.py:reinit()] - # Temperature devices: 1
2023-11-20 15:00:49,309 [printer.py:reinit()] - # Fans: 1
2023-11-20 15:00:49,310 [printer.py:reinit()] - # Output pins: 0
2023-11-20 15:00:49,310 [printer.py:reinit()] - # Leds: 0
2023-11-20 15:00:49,337 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-20 15:00:49,340 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-20 15:00:49,594 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-11-20 15:00:49,652 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-20 15:00:49,662 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-11-20 15:00:49,695 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-20 15:00:49,698 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-20 15:00:49,699 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-20 15:00:49,699 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-20 15:00:49,706 [screen.py:init_printer()] - Printer initialized
2023-11-20 15:00:49,708 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-20 15:00:49,708 [printer.py:change_state()] - Adding callback for state: startup
2023-11-20 15:00:51,043 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-20 15:00:51,043 [printer.py:change_state()] - Adding callback for state: ready
2023-11-20 15:00:51,051 [screen.py:show_panel()] - Reinitializing panel
2023-11-20 15:00:51,207 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-20 15:00:51,222 [main_menu.py:add_device()] - Adding device: extruder
2023-11-20 15:00:51,234 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-20 15:00:51,300 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-20 15:01:53,947 [functions.py:log_start()] - --------------------KlipperScreen Log Start--------------------
2023-11-20 15:01:53,948 [functions.py:log_start()] - KlipperScreen Version: v0.3.6-85-gad3b935
2023-11-20 15:01:53,949 [functions.py:log_start()] - Python version: 3.9
2023-11-20 15:01:54,235 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-11-20 15:01:54,238 [config.py:__init__()] - Config path location: /home/biqu/printer_data/config/KlipperScreen.conf
2023-11-20 15:01:54,276 [config.py:log_config()] -  ===== Config File =====

=======================
2023-11-20 15:01:54,280 [config.py:__init__()] - ====== Saved Def ======

[graph Printer]
extruder = False

=======================
2023-11-20 15:01:54,282 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-11-21 14:37:15,134 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-11-21 14:37:15,135 [config.py:install_language()] - Using system lang
2023-11-21 14:37:15,137 [config.py:install_language()] - Using lang en
2023-11-21 14:37:15,182 [screen.py:__init__()] - Screen resolution: 1024x600
2023-11-21 14:37:15,186 [KlippyGtk.py:__init__()] - Font size: 20.7 (medium)
2023-11-21 14:37:16,320 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-11-21 14:37:16,342 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-11-21 14:37:16,359 [screen.py:initial_connection()] - Default printer: None
2023-11-21 14:37:16,360 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-11-21 14:37:16,361 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-11-21 14:37:16,474 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-21 14:37:16,502 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-11-21 14:37:16,546 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-21 14:37:16,572 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-11-21 14:37:16,575 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-11-21 14:37:16,594 [_logging.py:info()] - Websocket connected
2023-11-21 14:37:16,595 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-11-21 14:37:16,722 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-21 14:37:16,757 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-21 14:37:16,760 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'update_manager', 'authorization', 'history'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-21 14:37:16,784 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-21 14:37:16,787 [printer.py:configure_cameras()] - Cameras: []
2023-11-21 14:37:16,814 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-21 14:37:16,977 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-21 14:37:16,981 [screen.py:init_printer()] - {'configfile': {'config': {'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': '2.', 'verbose': 'True'}, 'gcode_macro HELLO_WORLD': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world'}, 'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '23.940', 'pid_ki': '1.629', 'pid_kd': '87.981'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'min_temp': '0', 'max_temp': '130', 'control': 'pid', 'pid_kp': '69.445', 'pid_ki': '1.146', 'pid_kd': '1052.087'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5', 'z_offset': '-0.230'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': '90.0', 'verbose': 'True'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': 2.0, 'verbose': True}, 'gcode_macro hello_world': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world', 'description': 'G-Code macro'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 23.94, 'pid_ki': 1.629, 'pid_kd': 87.981, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 69.445, 'pid_ki': 1.146, 'pid_kd': 1052.087, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': -0.23, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script', 'description': 'G-Code macro'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': 90.0, 'verbose': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-21 14:37:16,985 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1-dirty
2023-11-21 14:37:16,986 [printer.py:reinit()] - # Extruders: 1
2023-11-21 14:37:16,986 [printer.py:reinit()] - # Temperature devices: 1
2023-11-21 14:37:16,987 [printer.py:reinit()] - # Fans: 1
2023-11-21 14:37:16,987 [printer.py:reinit()] - # Output pins: 0
2023-11-21 14:37:16,988 [printer.py:reinit()] - # Leds: 0
2023-11-21 14:37:17,031 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-21 14:37:17,035 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-21 14:37:17,281 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-11-21 14:37:17,308 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-21 14:37:17,310 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-11-21 14:37:17,311 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-21 14:37:17,312 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-21 14:37:17,313 [screen.py:init_printer()] - Printer initialized
2023-11-21 14:37:17,315 [printer.py:change_state()] - Changing state from 'disconnected' to 'ready'
2023-11-21 14:37:17,315 [printer.py:change_state()] - Adding callback for state: ready
2023-11-21 14:37:17,328 [screen.py:_load_panel()] - Loading panel: main_menu
2023-11-21 14:37:17,489 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-21 14:37:17,503 [main_menu.py:add_device()] - Adding device: extruder
2023-11-21 14:37:17,517 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-21 14:37:17,581 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-21 14:37:17,584 [main_menu.py:update_graph_visibility()] - Could not create graph tempstore: []
2023-11-21 14:37:22,909 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-21 14:37:22,935 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-11-21 14:37:22,966 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-21 14:37:22,968 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-21 14:41:32,384 [KlippyWebsocket.py:get_file_dir()] - Sending server.files.directory
2023-11-21 14:43:31,218 [files.py:_callback()] - Error in getting metadata for .thumbs/Mount_BDsensor_42mm_PLA_29m17s-300x300.png. Retrying in 6 seconds
2023-11-21 14:43:31,226 [files.py:_callback()] - Error in getting metadata for .thumbs/Mount_BDsensor_42mm_PLA_29m17s-32x32.png. Retrying in 6 seconds
2023-11-21 16:09:04,213 [functions.py:log_start()] - --------------------KlipperScreen Log Start--------------------
2023-11-21 16:09:04,214 [functions.py:log_start()] - KlipperScreen Version: v0.3.6-85-gad3b935
2023-11-21 16:09:04,215 [functions.py:log_start()] - Python version: 3.9
2023-11-21 16:09:04,815 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-11-21 16:09:04,817 [config.py:__init__()] - Config path location: /home/biqu/printer_data/config/KlipperScreen.conf
2023-11-21 16:09:04,860 [config.py:log_config()] -  ===== Config File =====

=======================
2023-11-21 16:09:04,865 [config.py:__init__()] - ====== Saved Def ======

[graph Printer]
extruder = False

=======================
2023-11-21 16:09:04,866 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-11-21 16:09:05,012 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-11-21 16:09:05,013 [config.py:install_language()] - Using system lang
2023-11-21 16:09:05,015 [config.py:install_language()] - Using lang en
2023-11-21 16:09:05,065 [screen.py:__init__()] - Screen resolution: 1024x600
2023-11-21 16:09:05,068 [KlippyGtk.py:__init__()] - Font size: 20.7 (medium)
2023-11-21 16:09:07,392 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-11-21 16:09:07,406 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-11-21 16:09:07,419 [screen.py:initial_connection()] - Default printer: None
2023-11-21 16:09:07,419 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-11-21 16:09:07,420 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-11-21 16:09:07,531 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-21 16:09:07,561 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-11-21 16:09:07,674 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-21 16:09:07,705 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-11-21 16:09:07,709 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-11-21 16:09:07,733 [_logging.py:info()] - Websocket connected
2023-11-21 16:09:07,734 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-11-21 16:09:07,827 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-21 16:09:07,853 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-21 16:09:07,856 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'authorization', 'update_manager', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-21 16:09:07,888 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-21 16:09:07,893 [printer.py:configure_cameras()] - Cameras: []
2023-11-21 16:09:07,897 [screen.py:init_printer()] - Klipper not connected
2023-11-21 16:09:11,634 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-21 16:09:11,664 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-21 16:09:11,669 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'authorization', 'update_manager', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-21 16:09:11,694 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-21 16:09:11,696 [printer.py:configure_cameras()] - Cameras: []
2023-11-21 16:09:11,697 [screen.py:init_printer()] - Klipper not connected
2023-11-21 16:09:14,600 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-21 16:09:14,627 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-21 16:09:14,630 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'authorization', 'update_manager', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-21 16:09:14,657 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-21 16:09:14,660 [printer.py:configure_cameras()] - Cameras: []
2023-11-21 16:09:14,709 [KlippyRest.py:_do_request()] - 404 Client Error>>Not Found for url>>http://127.0.0.1:7125/printer/info
2023-11-21 16:09:17,582 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-21 16:09:17,604 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-21 16:09:17,606 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'authorization', 'update_manager', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-21 16:09:17,627 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-21 16:09:17,629 [printer.py:configure_cameras()] - Cameras: []
2023-11-21 16:09:17,656 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-21 16:09:17,919 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-21 16:09:17,923 [screen.py:init_printer()] - {'configfile': {'config': {'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': '2.', 'verbose': 'True'}, 'gcode_macro HELLO_WORLD': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world'}, 'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '23.940', 'pid_ki': '1.629', 'pid_kd': '87.981'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'min_temp': '0', 'max_temp': '130', 'control': 'pid', 'pid_kp': '69.445', 'pid_ki': '1.146', 'pid_kd': '1052.087'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5', 'z_offset': '-0.230'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': '90.0', 'verbose': 'True'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': 2.0, 'verbose': True}, 'gcode_macro hello_world': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world', 'description': 'G-Code macro'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 23.94, 'pid_ki': 1.629, 'pid_kd': 87.981, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 69.445, 'pid_ki': 1.146, 'pid_kd': 1052.087, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': -0.23, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script', 'description': 'G-Code macro'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': 90.0, 'verbose': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-21 16:09:17,928 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1-dirty
2023-11-21 16:09:17,928 [printer.py:reinit()] - # Extruders: 1
2023-11-21 16:09:17,929 [printer.py:reinit()] - # Temperature devices: 1
2023-11-21 16:09:17,929 [printer.py:reinit()] - # Fans: 1
2023-11-21 16:09:17,930 [printer.py:reinit()] - # Output pins: 0
2023-11-21 16:09:17,930 [printer.py:reinit()] - # Leds: 0
2023-11-21 16:09:17,960 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-21 16:09:17,963 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-21 16:09:18,219 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-11-21 16:09:18,245 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-21 16:09:18,247 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-11-21 16:09:18,248 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-21 16:09:18,248 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-21 16:09:18,250 [screen.py:init_printer()] - Printer initialized
2023-11-21 16:09:18,251 [printer.py:change_state()] - Changing state from 'disconnected' to 'ready'
2023-11-21 16:09:18,251 [printer.py:change_state()] - Adding callback for state: ready
2023-11-21 16:09:18,259 [screen.py:_load_panel()] - Loading panel: main_menu
2023-11-21 16:09:18,424 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-21 16:09:18,439 [main_menu.py:add_device()] - Adding device: extruder
2023-11-21 16:09:18,452 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-21 16:09:18,523 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-21 16:09:18,526 [main_menu.py:update_graph_visibility()] - Could not create graph tempstore: []
2023-11-21 16:09:23,581 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-21 16:09:23,606 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-11-21 16:09:23,631 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-21 16:09:23,633 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-21 16:18:07,121 [printer.py:change_state()] - Changing state from 'ready' to 'disconnected'
2023-11-21 16:18:07,122 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-21 16:18:07,124 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-21 16:18:07,128 [screen.py:show_panel()] - Reinitializing panel
2023-11-21 16:18:07,216 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-21 16:18:10,585 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-21 16:18:10,608 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-21 16:18:10,610 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'authorization', 'update_manager', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-21 16:18:10,632 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-21 16:18:10,634 [printer.py:configure_cameras()] - Cameras: []
2023-11-21 16:18:10,838 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-21 16:18:10,874 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-21 16:18:10,878 [screen.py:init_printer()] - {'configfile': {'config': {'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': '2.', 'verbose': 'True'}, 'gcode_macro HELLO_WORLD': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world'}, 'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '23.940', 'pid_ki': '1.629', 'pid_kd': '87.981'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'min_temp': '0', 'max_temp': '130', 'control': 'pid', 'pid_kp': '69.445', 'pid_ki': '1.146', 'pid_kd': '1052.087'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5', 'z_offset': '-0.230'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'exclude_object': {}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': '90.0', 'verbose': 'True'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': 2.0, 'verbose': True}, 'gcode_macro hello_world': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world', 'description': 'G-Code macro'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 23.94, 'pid_ki': 1.629, 'pid_kd': 87.981, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 69.445, 'pid_ki': 1.146, 'pid_kd': 1052.087, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': -0.23, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script', 'description': 'G-Code macro'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': 90.0, 'verbose': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-21 16:18:10,882 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1-dirty
2023-11-21 16:18:10,883 [printer.py:reinit()] - # Extruders: 1
2023-11-21 16:18:10,884 [printer.py:reinit()] - # Temperature devices: 1
2023-11-21 16:18:10,884 [printer.py:reinit()] - # Fans: 1
2023-11-21 16:18:10,884 [printer.py:reinit()] - # Output pins: 0
2023-11-21 16:18:10,885 [printer.py:reinit()] - # Leds: 0
2023-11-21 16:18:10,911 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-21 16:18:10,914 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-21 16:18:11,170 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-11-21 16:18:11,208 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-21 16:18:11,230 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-11-21 16:18:11,254 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-21 16:18:11,256 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-21 16:18:11,257 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-21 16:18:11,258 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-21 16:18:11,260 [screen.py:init_printer()] - Printer initialized
2023-11-21 16:18:11,261 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-21 16:18:11,261 [printer.py:change_state()] - Adding callback for state: startup
2023-11-21 16:18:12,648 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-21 16:18:12,649 [printer.py:change_state()] - Adding callback for state: ready
2023-11-21 16:18:12,655 [screen.py:show_panel()] - Reinitializing panel
2023-11-21 16:18:12,851 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-21 16:18:12,868 [main_menu.py:add_device()] - Adding device: extruder
2023-11-21 16:18:12,885 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-21 16:18:12,968 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-21 16:19:16,384 [KlippyWebsocket.py:on_close()] - Server Shutdown
2023-11-21 16:19:16,386 [KlippyWebsocket.py:on_close()] - Moonraker Websocket Closed
2023-11-21 16:19:16,390 [screen.py:show_panel()] - Reinitializing panel
2023-11-21 16:19:16,524 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-21 16:19:16,551 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-11-21 16:19:16,554 [screen.py:show_panel()] - Reinitializing panel
2023-11-21 16:19:16,643 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-21 16:19:16,664 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-11-21 16:19:16,676 [KlippyRest.py:_do_request()] - host=127.0.0.1, port=7125>>Max retries exceeded with url>>Failed to establish a new connection>>[Errno 111] Connection refused
2023-11-21 16:19:26,563 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-11-21 16:19:26,587 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-21 16:19:26,608 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-11-21 16:19:26,611 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-11-21 16:19:26,626 [_logging.py:info()] - Websocket connected
2023-11-21 16:19:26,626 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-11-21 16:19:26,649 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-21 16:19:26,671 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-21 16:19:26,673 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'ready', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'authorization', 'update_manager', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-21 16:19:26,698 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-21 16:19:26,701 [printer.py:configure_cameras()] - Cameras: []
2023-11-21 16:19:26,725 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-21 16:19:26,909 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-21 16:19:26,913 [screen.py:init_printer()] - {'configfile': {'config': {'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': '2.', 'verbose': 'True'}, 'gcode_macro HELLO_WORLD': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world'}, 'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '23.940', 'pid_ki': '1.629', 'pid_kd': '87.981'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'min_temp': '0', 'max_temp': '130', 'control': 'pid', 'pid_kp': '69.445', 'pid_ki': '1.146', 'pid_kd': '1052.087'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5', 'z_offset': '-0.230'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'exclude_object': {}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': '90.0', 'verbose': 'True'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': 2.0, 'verbose': True}, 'gcode_macro hello_world': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world', 'description': 'G-Code macro'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 23.94, 'pid_ki': 1.629, 'pid_kd': 87.981, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 69.445, 'pid_ki': 1.146, 'pid_kd': 1052.087, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': -0.23, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script', 'description': 'G-Code macro'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': 90.0, 'verbose': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-21 16:19:26,917 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1-dirty
2023-11-21 16:19:26,918 [printer.py:reinit()] - # Extruders: 1
2023-11-21 16:19:26,919 [printer.py:reinit()] - # Temperature devices: 1
2023-11-21 16:19:26,919 [printer.py:reinit()] - # Fans: 1
2023-11-21 16:19:26,920 [printer.py:reinit()] - # Output pins: 0
2023-11-21 16:19:26,920 [printer.py:reinit()] - # Leds: 0
2023-11-21 16:19:26,947 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-21 16:19:26,950 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-21 16:19:27,208 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-11-21 16:19:27,235 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-21 16:19:27,263 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-11-21 16:19:27,295 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-21 16:19:27,298 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-21 16:19:27,298 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-21 16:19:27,299 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-21 16:19:27,301 [screen.py:init_printer()] - Printer initialized
2023-11-21 16:19:27,302 [printer.py:change_state()] - Changing state from 'disconnected' to 'ready'
2023-11-21 16:19:27,302 [printer.py:change_state()] - Adding callback for state: ready
2023-11-21 16:19:27,313 [screen.py:show_panel()] - Reinitializing panel
2023-11-21 16:19:27,482 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-21 16:19:27,500 [main_menu.py:add_device()] - Adding device: extruder
2023-11-21 16:19:27,514 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-21 16:19:27,585 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-21 16:19:58,517 [screen.py:_go_to_submenu()] - #### Go to submenu more
2023-11-21 16:19:58,518 [screen.py:_go_to_submenu()] - #### Menu __main
2023-11-21 16:19:58,530 [screen.py:_load_panel()] - Loading panel: menu
2023-11-21 16:19:59,088 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > more
2023-11-21 16:19:59,100 [menu.py:arrangeMenuItems()] - X > more bedlevel
2023-11-21 16:19:59,122 [menu.py:arrangeMenuItems()] - X > more retraction
2023-11-21 16:19:59,140 [menu.py:arrangeMenuItems()] - X > more led
2023-11-21 16:19:59,157 [menu.py:arrangeMenuItems()] - X > more pins
2023-11-21 16:19:59,166 [menu.py:arrangeMenuItems()] - X > more power
2023-11-21 16:19:59,174 [menu.py:arrangeMenuItems()] - X > more camera
2023-11-21 16:19:59,189 [menu.py:arrangeMenuItems()] - X > more input_shaper
2023-11-21 16:19:59,211 [menu.py:arrangeMenuItems()] - X > more spoolman
2023-11-21 16:20:01,189 [screen.py:_menu_go_back()] - #### Menu go back
2023-11-21 16:20:01,228 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-21 16:24:38,173 [KlippyWebsocket.py:on_close()] - Server Shutdown
2023-11-21 16:24:38,174 [KlippyWebsocket.py:on_close()] - Moonraker Websocket Closed
2023-11-21 16:24:38,178 [screen.py:show_panel()] - Reinitializing panel
2023-11-21 16:24:38,312 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-21 16:24:38,342 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-11-21 16:24:38,344 [screen.py:show_panel()] - Reinitializing panel
2023-11-21 16:24:38,433 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-21 16:24:38,454 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-11-21 16:24:38,466 [KlippyRest.py:_do_request()] - host=127.0.0.1, port=7125>>Max retries exceeded with url>>Failed to establish a new connection>>[Errno 111] Connection refused
2023-11-21 16:24:48,563 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-11-21 16:24:48,587 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-21 16:24:48,609 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-11-21 16:24:48,611 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-11-21 16:24:48,625 [_logging.py:info()] - Websocket connected
2023-11-21 16:24:48,625 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-11-21 16:24:48,649 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-21 16:24:48,671 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-21 16:24:48,673 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'ready', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'authorization', 'update_manager', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-21 16:24:48,694 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-21 16:24:48,696 [printer.py:configure_cameras()] - Cameras: []
2023-11-21 16:24:48,720 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-21 16:24:48,921 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-21 16:24:48,924 [screen.py:init_printer()] - {'configfile': {'config': {'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': '2.', 'verbose': 'True'}, 'gcode_macro HELLO_WORLD': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world'}, 'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '23.940', 'pid_ki': '1.629', 'pid_kd': '87.981'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'min_temp': '0', 'max_temp': '130', 'control': 'pid', 'pid_kp': '69.445', 'pid_ki': '1.146', 'pid_kd': '1052.087'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5', 'z_offset': '-0.230'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'exclude_object': {}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': '90.0', 'verbose': 'True'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': 2.0, 'verbose': True}, 'gcode_macro hello_world': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world', 'description': 'G-Code macro'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 23.94, 'pid_ki': 1.629, 'pid_kd': 87.981, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 69.445, 'pid_ki': 1.146, 'pid_kd': 1052.087, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': -0.23, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script', 'description': 'G-Code macro'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': 90.0, 'verbose': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-21 16:24:48,928 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1-dirty
2023-11-21 16:24:48,929 [printer.py:reinit()] - # Extruders: 1
2023-11-21 16:24:48,930 [printer.py:reinit()] - # Temperature devices: 1
2023-11-21 16:24:48,930 [printer.py:reinit()] - # Fans: 1
2023-11-21 16:24:48,930 [printer.py:reinit()] - # Output pins: 0
2023-11-21 16:24:48,931 [printer.py:reinit()] - # Leds: 0
2023-11-21 16:24:48,961 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-21 16:24:48,964 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-21 16:24:49,220 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-11-21 16:24:49,244 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-21 16:24:49,270 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-11-21 16:24:49,293 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-21 16:24:49,295 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-21 16:24:49,296 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-21 16:24:49,297 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-21 16:24:49,298 [screen.py:init_printer()] - Printer initialized
2023-11-21 16:24:49,299 [printer.py:change_state()] - Changing state from 'disconnected' to 'ready'
2023-11-21 16:24:49,300 [printer.py:change_state()] - Adding callback for state: ready
2023-11-21 16:24:49,307 [screen.py:show_panel()] - Reinitializing panel
2023-11-21 16:24:49,462 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-21 16:24:49,478 [main_menu.py:add_device()] - Adding device: extruder
2023-11-21 16:24:49,491 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-21 16:24:49,556 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-21 16:27:10,808 [printer.py:change_state()] - Changing state from 'ready' to 'disconnected'
2023-11-21 16:27:10,809 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-21 16:27:10,811 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-21 16:27:10,815 [screen.py:show_panel()] - Reinitializing panel
2023-11-21 16:27:10,921 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-21 16:27:14,582 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-21 16:27:14,604 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-21 16:27:14,606 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'authorization', 'update_manager', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-21 16:27:14,629 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-21 16:27:14,631 [printer.py:configure_cameras()] - Cameras: []
2023-11-21 16:27:14,657 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-21 16:27:14,693 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-21 16:27:14,697 [screen.py:init_printer()] - {'configfile': {'config': {'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': '2.', 'verbose': 'True'}, 'gcode_macro HELLO_WORLD': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world'}, 'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '23.940', 'pid_ki': '1.629', 'pid_kd': '87.981'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'min_temp': '0', 'max_temp': '130', 'control': 'pid', 'pid_kp': '69.445', 'pid_ki': '1.146', 'pid_kd': '1052.087'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5', 'z_offset': '-0.230'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'exclude_object': {}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': '90.0', 'verbose': 'True'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': 2.0, 'verbose': True}, 'gcode_macro hello_world': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world', 'description': 'G-Code macro'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 23.94, 'pid_ki': 1.629, 'pid_kd': 87.981, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 69.445, 'pid_ki': 1.146, 'pid_kd': 1052.087, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': -0.23, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script', 'description': 'G-Code macro'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': 90.0, 'verbose': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-21 16:27:14,701 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1-dirty
2023-11-21 16:27:14,702 [printer.py:reinit()] - # Extruders: 1
2023-11-21 16:27:14,703 [printer.py:reinit()] - # Temperature devices: 1
2023-11-21 16:27:14,703 [printer.py:reinit()] - # Fans: 1
2023-11-21 16:27:14,704 [printer.py:reinit()] - # Output pins: 0
2023-11-21 16:27:14,704 [printer.py:reinit()] - # Leds: 0
2023-11-21 16:27:14,733 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-21 16:27:14,737 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-21 16:27:14,989 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-11-21 16:27:15,017 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-21 16:27:15,042 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-11-21 16:27:15,070 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-21 16:27:15,073 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-21 16:27:15,074 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-21 16:27:15,074 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-21 16:27:15,076 [screen.py:init_printer()] - Printer initialized
2023-11-21 16:27:15,077 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-21 16:27:15,077 [printer.py:change_state()] - Adding callback for state: startup
2023-11-21 16:27:16,441 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-21 16:27:16,442 [printer.py:change_state()] - Adding callback for state: ready
2023-11-21 16:27:16,449 [screen.py:show_panel()] - Reinitializing panel
2023-11-21 16:27:16,644 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-21 16:27:16,661 [main_menu.py:add_device()] - Adding device: extruder
2023-11-21 16:27:16,676 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-21 16:27:16,753 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-21 16:37:54,883 [printer.py:change_state()] - Changing state from 'ready' to 'disconnected'
2023-11-21 16:37:54,884 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-21 16:37:54,887 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-21 16:37:54,891 [screen.py:show_panel()] - Reinitializing panel
2023-11-21 16:37:54,995 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-21 16:37:58,585 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-21 16:37:58,610 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-21 16:37:58,612 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'authorization', 'update_manager', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 3, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-21 16:37:58,641 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-21 16:37:58,643 [printer.py:configure_cameras()] - Cameras: []
2023-11-21 16:37:59,218 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-21 16:37:59,260 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-21 16:37:59,264 [screen.py:init_printer()] - {'configfile': {'config': {'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': '2.', 'verbose': 'True'}, 'gcode_macro HELLO_WORLD': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world'}, 'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '23.940', 'pid_ki': '1.629', 'pid_kd': '87.981'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'min_temp': '0', 'max_temp': '130', 'control': 'pid', 'pid_kp': '69.445', 'pid_ki': '1.146', 'pid_kd': '1052.087'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5', 'z_offset': '-0.230'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'exclude_object': {}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': '90.0', 'verbose': 'True'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': 2.0, 'verbose': True}, 'gcode_macro hello_world': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world', 'description': 'G-Code macro'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 23.94, 'pid_ki': 1.629, 'pid_kd': 87.981, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 69.445, 'pid_ki': 1.146, 'pid_kd': 1052.087, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': -0.23, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script', 'description': 'G-Code macro'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': 90.0, 'verbose': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-21 16:37:59,270 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1-dirty
2023-11-21 16:37:59,270 [printer.py:reinit()] - # Extruders: 1
2023-11-21 16:37:59,270 [printer.py:reinit()] - # Temperature devices: 1
2023-11-21 16:37:59,271 [printer.py:reinit()] - # Fans: 1
2023-11-21 16:37:59,271 [printer.py:reinit()] - # Output pins: 0
2023-11-21 16:37:59,271 [printer.py:reinit()] - # Leds: 0
2023-11-21 16:37:59,299 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-21 16:37:59,302 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-21 16:37:59,591 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-11-21 16:37:59,633 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-21 16:37:59,652 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-11-21 16:37:59,677 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-21 16:37:59,680 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-21 16:37:59,681 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-21 16:37:59,681 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-21 16:37:59,683 [screen.py:init_printer()] - Printer initialized
2023-11-21 16:37:59,684 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-21 16:37:59,684 [printer.py:change_state()] - Adding callback for state: startup
2023-11-21 16:38:01,260 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-21 16:38:01,261 [printer.py:change_state()] - Adding callback for state: ready
2023-11-21 16:38:01,270 [screen.py:show_panel()] - Reinitializing panel
2023-11-21 16:38:01,439 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-21 16:38:01,454 [main_menu.py:add_device()] - Adding device: extruder
2023-11-21 16:38:01,467 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-21 16:38:01,533 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-21 17:18:02,850 [functions.py:log_start()] - --------------------KlipperScreen Log Start--------------------
2023-11-21 17:18:02,851 [functions.py:log_start()] - KlipperScreen Version: v0.3.6-85-gad3b935
2023-11-21 17:18:02,852 [functions.py:log_start()] - Python version: 3.9
2023-11-21 17:18:03,127 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-11-21 17:18:03,130 [config.py:__init__()] - Config path location: /home/biqu/printer_data/config/KlipperScreen.conf
2023-11-21 17:18:03,175 [config.py:log_config()] -  ===== Config File =====

=======================
2023-11-21 17:18:03,180 [config.py:__init__()] - ====== Saved Def ======

[graph Printer]
extruder = False

=======================
2023-11-21 17:18:03,182 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-11-21 17:18:03,319 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-11-21 17:18:03,320 [config.py:install_language()] - Using system lang
2023-11-21 17:18:03,321 [config.py:install_language()] - Using lang en
2023-11-21 17:18:03,359 [screen.py:__init__()] - Screen resolution: 1024x600
2023-11-21 17:18:03,362 [KlippyGtk.py:__init__()] - Font size: 20.7 (medium)
2023-11-22 17:00:40,392 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-11-22 17:00:40,406 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-11-22 17:00:40,417 [screen.py:initial_connection()] - Default printer: None
2023-11-22 17:00:40,418 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-11-22 17:00:40,419 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-11-22 17:00:40,515 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-22 17:00:40,533 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-11-22 17:00:40,568 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-22 17:00:40,603 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-11-22 17:00:40,611 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-11-22 17:00:40,727 [_logging.py:info()] - Websocket connected
2023-11-22 17:00:40,727 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-11-22 17:00:40,821 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-22 17:00:40,848 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-22 17:00:40,850 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'authorization', 'octoprint_compat', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-22 17:00:40,876 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-22 17:00:40,879 [printer.py:configure_cameras()] - Cameras: []
2023-11-22 17:00:40,928 [KlippyRest.py:_do_request()] - 404 Client Error>>Not Found for url>>http://127.0.0.1:7125/printer/info
2023-11-22 17:00:41,819 [screen.py:_websocket_callback()] - Still not initialized
2023-11-22 17:00:44,052 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-22 17:00:44,074 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-22 17:00:44,076 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'ready', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'authorization', 'octoprint_compat', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-22 17:00:44,097 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-22 17:00:44,100 [printer.py:configure_cameras()] - Cameras: []
2023-11-22 17:00:44,124 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-22 17:00:44,292 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-22 17:00:44,296 [screen.py:init_printer()] - {'configfile': {'config': {'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': '2.', 'verbose': 'True'}, 'gcode_macro HELLO_WORLD': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world'}, 'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '23.940', 'pid_ki': '1.629', 'pid_kd': '87.981'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'min_temp': '0', 'max_temp': '130', 'control': 'pid', 'pid_kp': '69.445', 'pid_ki': '1.146', 'pid_kd': '1052.087'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5', 'z_offset': '-0.230'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'exclude_object': {}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': '90.0', 'verbose': 'True'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': 2.0, 'verbose': True}, 'gcode_macro hello_world': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world', 'description': 'G-Code macro'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 23.94, 'pid_ki': 1.629, 'pid_kd': 87.981, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 69.445, 'pid_ki': 1.146, 'pid_kd': 1052.087, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': -0.23, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script', 'description': 'G-Code macro'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': 90.0, 'verbose': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-22 17:00:44,301 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1-dirty
2023-11-22 17:00:44,302 [printer.py:reinit()] - # Extruders: 1
2023-11-22 17:00:44,302 [printer.py:reinit()] - # Temperature devices: 1
2023-11-22 17:00:44,302 [printer.py:reinit()] - # Fans: 1
2023-11-22 17:00:44,302 [printer.py:reinit()] - # Output pins: 0
2023-11-22 17:00:44,303 [printer.py:reinit()] - # Leds: 0
2023-11-22 17:00:44,332 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-22 17:00:44,335 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-22 17:00:44,629 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-11-22 17:00:44,657 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-22 17:00:44,683 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-11-22 17:00:44,707 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-22 17:00:44,710 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-22 17:00:44,711 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-22 17:00:44,711 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-22 17:00:44,712 [screen.py:init_printer()] - Printer initialized
2023-11-22 17:00:44,714 [printer.py:change_state()] - Changing state from 'disconnected' to 'ready'
2023-11-22 17:00:44,714 [printer.py:change_state()] - Adding callback for state: ready
2023-11-22 17:00:44,726 [screen.py:_load_panel()] - Loading panel: main_menu
2023-11-22 17:00:44,886 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-22 17:00:44,902 [main_menu.py:add_device()] - Adding device: extruder
2023-11-22 17:00:44,915 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-22 17:00:44,981 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-22 17:01:21,160 [screen.py:_load_panel()] - Loading panel: move
2023-11-22 17:01:21,325 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > move
2023-11-22 17:01:23,210 [screen.py:_load_panel()] - Loading panel: menu
2023-11-22 17:01:23,423 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > move > menu
2023-11-22 17:01:23,451 [menu.py:arrangeMenuItems()] - X > homing quad_gantry_level
2023-11-22 17:01:23,458 [menu.py:arrangeMenuItems()] - X > homing Z-Tilt
2023-11-22 17:01:24,885 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G28'}
2023-11-22 17:01:36,953 [screen.py:_menu_go_back()] - #### Menu go back
2023-11-22 17:01:36,996 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > move
2023-11-22 17:01:45,533 [move.py:change_distance()] - ### Distance 50
2023-11-22 17:01:49,182 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 Z+50 F600'}
2023-11-22 17:01:49,188 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-22 17:01:50,686 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 Z+50 F600'}
2023-11-22 17:01:50,692 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-22 17:02:23,846 [screen.py:_menu_go_back()] - #### Menu go back
2023-11-22 17:02:23,887 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-23 15:41:21,288 [functions.py:log_start()] - --------------------KlipperScreen Log Start--------------------
2023-11-23 15:41:21,290 [functions.py:log_start()] - KlipperScreen Version: v0.3.6-85-gad3b935
2023-11-23 15:41:21,291 [functions.py:log_start()] - Python version: 3.9
2023-11-23 15:41:21,750 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-11-23 15:41:21,751 [config.py:__init__()] - Config path location: /home/biqu/printer_data/config/KlipperScreen.conf
2023-11-23 15:41:21,794 [config.py:log_config()] -  ===== Config File =====

=======================
2023-11-23 15:41:21,798 [config.py:__init__()] - ====== Saved Def ======

[graph Printer]
extruder = False

=======================
2023-11-23 15:41:21,800 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-11-23 15:41:21,936 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-11-23 15:41:21,937 [config.py:install_language()] - Using system lang
2023-11-23 15:41:21,938 [config.py:install_language()] - Using lang en
2023-11-23 15:41:21,983 [screen.py:__init__()] - Screen resolution: 1024x600
2023-11-23 15:41:21,986 [KlippyGtk.py:__init__()] - Font size: 20.7 (medium)
2023-11-23 15:41:24,973 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-11-23 15:41:24,989 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-11-23 15:41:25,000 [screen.py:initial_connection()] - Default printer: None
2023-11-23 15:41:25,001 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-11-23 15:41:25,002 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-11-23 15:41:25,223 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-23 15:41:25,243 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-11-23 15:41:25,283 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-23 15:41:25,307 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-11-23 15:41:25,310 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-11-23 15:41:25,330 [_logging.py:info()] - Websocket connected
2023-11-23 15:41:25,330 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-11-23 15:41:25,449 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-23 15:41:25,471 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-23 15:41:25,474 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'history', 'authorization', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-23 15:41:25,498 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-23 15:41:25,500 [printer.py:configure_cameras()] - Cameras: []
2023-11-23 15:41:25,501 [screen.py:init_printer()] - Klipper not connected
2023-11-23 15:41:28,597 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-23 15:41:28,619 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-23 15:41:28,622 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'history', 'authorization', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-23 15:41:28,643 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-23 15:41:28,646 [printer.py:configure_cameras()] - Cameras: []
2023-11-23 15:41:28,646 [screen.py:init_printer()] - Klipper not connected
2023-11-23 15:41:31,611 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-23 15:41:31,641 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-23 15:41:31,644 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'history', 'authorization', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-23 15:41:31,670 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-23 15:41:31,674 [printer.py:configure_cameras()] - Cameras: []
2023-11-23 15:41:31,719 [KlippyRest.py:_do_request()] - 404 Client Error>>Not Found for url>>http://127.0.0.1:7125/printer/info
2023-11-23 15:41:34,595 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-23 15:41:34,618 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-23 15:41:34,620 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'history', 'authorization', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-23 15:41:34,642 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-23 15:41:34,645 [printer.py:configure_cameras()] - Cameras: []
2023-11-23 15:41:34,668 [KlippyRest.py:_do_request()] - 404 Client Error>>Not Found for url>>http://127.0.0.1:7125/printer/info
2023-11-23 15:41:37,599 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-23 15:41:37,623 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-23 15:41:37,626 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'ready', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'history', 'authorization', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-23 15:41:37,649 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-23 15:41:37,651 [printer.py:configure_cameras()] - Cameras: []
2023-11-23 15:41:37,681 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-23 15:41:37,815 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-23 15:41:37,820 [screen.py:init_printer()] - {'configfile': {'config': {'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': '2.', 'verbose': 'True'}, 'gcode_macro HELLO_WORLD': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world'}, 'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '23.940', 'pid_ki': '1.629', 'pid_kd': '87.981'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'min_temp': '0', 'max_temp': '130', 'control': 'pid', 'pid_kp': '69.445', 'pid_ki': '1.146', 'pid_kd': '1052.087'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5', 'z_offset': '-0.230'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'exclude_object': {}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': '90.0', 'verbose': 'True'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': 2.0, 'verbose': True}, 'gcode_macro hello_world': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world', 'description': 'G-Code macro'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 23.94, 'pid_ki': 1.629, 'pid_kd': 87.981, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 69.445, 'pid_ki': 1.146, 'pid_kd': 1052.087, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': -0.23, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script', 'description': 'G-Code macro'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': 90.0, 'verbose': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-23 15:41:37,825 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1-dirty
2023-11-23 15:41:37,825 [printer.py:reinit()] - # Extruders: 1
2023-11-23 15:41:37,826 [printer.py:reinit()] - # Temperature devices: 1
2023-11-23 15:41:37,827 [printer.py:reinit()] - # Fans: 1
2023-11-23 15:41:37,827 [printer.py:reinit()] - # Output pins: 0
2023-11-23 15:41:37,828 [printer.py:reinit()] - # Leds: 0
2023-11-23 15:41:37,863 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-23 15:41:37,867 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-23 15:41:38,077 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-11-23 15:41:38,105 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-23 15:41:38,131 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-11-23 15:41:38,157 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-23 15:41:38,160 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-23 15:41:38,161 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-23 15:41:38,162 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-23 15:41:38,163 [screen.py:init_printer()] - Printer initialized
2023-11-23 15:41:38,165 [printer.py:change_state()] - Changing state from 'disconnected' to 'ready'
2023-11-23 15:41:38,165 [printer.py:change_state()] - Adding callback for state: ready
2023-11-23 15:41:38,174 [screen.py:_load_panel()] - Loading panel: main_menu
2023-11-23 15:41:38,362 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-23 15:41:38,380 [main_menu.py:add_device()] - Adding device: extruder
2023-11-23 15:41:38,395 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-23 15:41:38,481 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-23 15:41:48,085 [printer.py:change_state()] - Changing state from 'ready' to 'shutdown'
2023-11-23 15:41:48,085 [printer.py:change_state()] - Adding callback for state: shutdown
2023-11-23 15:41:48,097 [screen.py:show_panel()] - Reinitializing panel
2023-11-23 15:41:48,189 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-23 15:41:53,363 [KlippyWebsocket.py:connect()] - Already connected
2023-11-23 15:42:11,865 [KlippyWebsocket.py:restart_firmware()] - Sending printer.firmware_restart
2023-11-23 15:42:11,890 [printer.py:change_state()] - Changing state from 'shutdown' to 'disconnected'
2023-11-23 15:42:11,891 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-23 15:42:11,893 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-23 15:42:11,895 [screen.py:show_panel()] - Reinitializing panel
2023-11-23 15:42:11,998 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-23 15:42:15,597 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-23 15:42:15,619 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-23 15:42:15,622 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'history', 'authorization', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-23 15:42:15,645 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-23 15:42:15,647 [printer.py:configure_cameras()] - Cameras: []
2023-11-23 15:42:16,538 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-23 15:42:16,578 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-23 15:42:16,582 [screen.py:init_printer()] - {'configfile': {'config': {'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': '2.', 'verbose': 'True'}, 'gcode_macro HELLO_WORLD': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world'}, 'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '23.940', 'pid_ki': '1.629', 'pid_kd': '87.981'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'min_temp': '0', 'max_temp': '130', 'control': 'pid', 'pid_kp': '69.445', 'pid_ki': '1.146', 'pid_kd': '1052.087'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5', 'z_offset': '-0.230'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'exclude_object': {}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': '90.0', 'verbose': 'True'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': 2.0, 'verbose': True}, 'gcode_macro hello_world': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world', 'description': 'G-Code macro'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 23.94, 'pid_ki': 1.629, 'pid_kd': 87.981, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 69.445, 'pid_ki': 1.146, 'pid_kd': 1052.087, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': -0.23, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script', 'description': 'G-Code macro'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': 90.0, 'verbose': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-23 15:42:16,587 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1-dirty
2023-11-23 15:42:16,588 [printer.py:reinit()] - # Extruders: 1
2023-11-23 15:42:16,588 [printer.py:reinit()] - # Temperature devices: 1
2023-11-23 15:42:16,589 [printer.py:reinit()] - # Fans: 1
2023-11-23 15:42:16,589 [printer.py:reinit()] - # Output pins: 0
2023-11-23 15:42:16,589 [printer.py:reinit()] - # Leds: 0
2023-11-23 15:42:16,618 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-23 15:42:16,621 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-23 15:42:16,910 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-11-23 15:42:16,944 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-23 15:42:16,971 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-11-23 15:42:16,995 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-23 15:42:16,998 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-23 15:42:16,999 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-23 15:42:17,000 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-23 15:42:17,001 [screen.py:init_printer()] - Printer initialized
2023-11-23 15:42:17,002 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-23 15:42:17,003 [printer.py:change_state()] - Adding callback for state: startup
2023-11-23 15:42:17,821 [printer.py:change_state()] - Changing state from 'startup' to 'error'
2023-11-23 15:42:17,821 [printer.py:change_state()] - Adding callback for state: error
2023-11-23 15:42:17,827 [screen.py:show_panel()] - Reinitializing panel
2023-11-23 15:42:17,934 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-22 17:17:22,104 [functions.py:log_start()] - --------------------KlipperScreen Log Start--------------------
2023-11-22 17:17:22,105 [functions.py:log_start()] - KlipperScreen Version: v0.3.6-85-gad3b935
2023-11-22 17:17:22,106 [functions.py:log_start()] - Python version: 3.9
2023-11-22 17:17:22,714 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-11-22 17:17:22,716 [config.py:__init__()] - Config path location: /home/biqu/printer_data/config/KlipperScreen.conf
2023-11-22 17:17:22,816 [config.py:log_config()] -  ===== Config File =====

=======================
2023-11-22 17:17:22,828 [config.py:__init__()] - ====== Saved Def ======

[graph Printer]
extruder = False

=======================
2023-11-22 17:17:22,830 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-11-22 17:17:23,340 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-11-22 17:17:23,341 [config.py:install_language()] - Using system lang
2023-11-22 17:17:23,347 [config.py:install_language()] - Using lang en
2023-11-22 17:17:23,416 [screen.py:__init__()] - Screen resolution: 1024x600
2023-11-22 17:17:23,421 [KlippyGtk.py:__init__()] - Font size: 20.7 (medium)
2023-11-23 15:43:01,146 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-11-23 15:43:01,162 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-11-23 15:43:01,175 [screen.py:initial_connection()] - Default printer: None
2023-11-23 15:43:01,175 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-11-23 15:43:01,177 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-11-23 15:43:01,339 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-23 15:43:01,370 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-11-23 15:43:01,420 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-23 15:43:01,454 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-11-23 15:43:01,458 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-11-23 15:43:01,482 [_logging.py:info()] - Websocket connected
2023-11-23 15:43:01,483 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-11-23 15:43:01,605 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-23 15:43:01,634 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-23 15:43:01,637 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'authorization', 'octoprint_compat', 'history'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-23 15:43:01,666 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-23 15:43:01,668 [printer.py:configure_cameras()] - Cameras: []
2023-11-23 15:43:01,698 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-23 15:43:01,740 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-23 15:43:01,745 [screen.py:init_printer()] - {'configfile': {'config': {'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': '2.', 'verbose': 'True'}, 'gcode_macro HELLO_WORLD': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world'}, 'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '23.940', 'pid_ki': '1.629', 'pid_kd': '87.981'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'min_temp': '0', 'max_temp': '130', 'control': 'pid', 'pid_kp': '69.445', 'pid_ki': '1.146', 'pid_kd': '1052.087'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5', 'z_offset': '-0.230'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'exclude_object': {}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': '90.0', 'verbose': 'True'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': 2.0, 'verbose': True}, 'gcode_macro hello_world': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world', 'description': 'G-Code macro'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 23.94, 'pid_ki': 1.629, 'pid_kd': 87.981, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 69.445, 'pid_ki': 1.146, 'pid_kd': 1052.087, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': -0.23, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script', 'description': 'G-Code macro'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': 90.0, 'verbose': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-23 15:43:01,750 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1-dirty
2023-11-23 15:43:01,751 [printer.py:reinit()] - # Extruders: 1
2023-11-23 15:43:01,751 [printer.py:reinit()] - # Temperature devices: 1
2023-11-23 15:43:01,752 [printer.py:reinit()] - # Fans: 1
2023-11-23 15:43:01,752 [printer.py:reinit()] - # Output pins: 0
2023-11-23 15:43:01,753 [printer.py:reinit()] - # Leds: 0
2023-11-23 15:43:01,792 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-23 15:43:01,796 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-23 15:43:02,076 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-11-23 15:43:02,118 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-23 15:43:02,120 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-11-23 15:43:02,122 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-23 15:43:02,122 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-23 15:43:02,124 [screen.py:init_printer()] - Printer initialized
2023-11-23 15:43:02,125 [printer.py:change_state()] - Changing state from 'disconnected' to 'ready'
2023-11-23 15:43:02,126 [printer.py:change_state()] - Adding callback for state: ready
2023-11-23 15:43:02,133 [screen.py:_load_panel()] - Loading panel: main_menu
2023-11-23 15:43:02,327 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-23 15:43:02,345 [main_menu.py:add_device()] - Adding device: extruder
2023-11-23 15:43:02,362 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-23 15:43:02,428 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-23 15:43:02,431 [main_menu.py:update_graph_visibility()] - Could not create graph tempstore: []
2023-11-23 15:43:07,352 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-23 15:43:07,379 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-11-23 15:43:07,416 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-23 15:43:07,418 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-23 15:50:15,060 [screen.py:show_popup_message()] - error: Must home axis first: 0.000 0.000 10.000 [0.000]
2023-11-23 15:50:15,145 [screen.py:show_popup_message()] - error: Must home axis first: 0.000 0.000 10.000 [0.000]
2023-11-23 15:50:25,577 [screen.py:_load_panel()] - Loading panel: move
2023-11-23 15:50:25,759 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > move
2023-11-23 15:50:26,996 [screen.py:_load_panel()] - Loading panel: menu
2023-11-23 15:50:27,246 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > move > menu
2023-11-23 15:50:27,278 [menu.py:arrangeMenuItems()] - X > homing quad_gantry_level
2023-11-23 15:50:27,287 [menu.py:arrangeMenuItems()] - X > homing Z-Tilt
2023-11-23 15:50:28,703 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G28'}
2023-11-23 15:59:41,431 [functions.py:log_start()] - --------------------KlipperScreen Log Start--------------------
2023-11-23 15:59:41,432 [functions.py:log_start()] - KlipperScreen Version: v0.3.6-85-gad3b935
2023-11-23 15:59:41,432 [functions.py:log_start()] - Python version: 3.9
2023-11-23 15:59:41,974 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-11-23 15:59:41,977 [config.py:__init__()] - Config path location: /home/biqu/printer_data/config/KlipperScreen.conf
2023-11-23 15:59:42,024 [config.py:log_config()] -  ===== Config File =====

=======================
2023-11-23 15:59:42,028 [config.py:__init__()] - ====== Saved Def ======

[graph Printer]
extruder = False

=======================
2023-11-23 15:59:42,030 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-11-23 15:59:42,188 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-11-23 15:59:42,189 [config.py:install_language()] - Using system lang
2023-11-23 15:59:42,190 [config.py:install_language()] - Using lang en
2023-11-23 15:59:42,343 [screen.py:__init__()] - Screen resolution: 1024x600
2023-11-23 15:59:42,347 [KlippyGtk.py:__init__()] - Font size: 20.7 (medium)
2023-11-23 15:59:45,041 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-11-23 15:59:45,056 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-11-23 15:59:45,068 [screen.py:initial_connection()] - Default printer: None
2023-11-23 15:59:45,069 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-11-23 15:59:45,069 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-11-23 15:59:45,185 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-23 15:59:45,204 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-11-23 15:59:45,248 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-23 15:59:45,272 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-11-23 15:59:45,274 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-11-23 15:59:45,296 [_logging.py:info()] - Websocket connected
2023-11-23 15:59:45,296 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-11-23 15:59:45,413 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-23 15:59:45,447 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-23 15:59:45,449 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'update_manager', 'history', 'authorization'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-23 15:59:45,475 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-23 15:59:45,478 [printer.py:configure_cameras()] - Cameras: []
2023-11-23 15:59:45,479 [screen.py:init_printer()] - Klipper not connected
2023-11-23 15:59:49,252 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-23 15:59:49,277 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-23 15:59:49,280 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'update_manager', 'history', 'authorization'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-23 15:59:49,307 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-23 15:59:49,309 [printer.py:configure_cameras()] - Cameras: []
2023-11-23 15:59:49,310 [screen.py:init_printer()] - Klipper not connected
2023-11-23 15:59:52,253 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-23 15:59:52,281 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-23 15:59:52,283 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'error', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'update_manager', 'history', 'authorization'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-23 15:59:52,308 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-23 15:59:52,310 [printer.py:configure_cameras()] - Cameras: []
2023-11-23 15:59:52,340 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-23 15:59:52,476 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-23 15:59:52,479 [screen.py:init_printer()] - {'configfile': {'config': {}, 'settings': {}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-23 15:59:52,480 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1-dirty
2023-11-23 15:59:52,481 [printer.py:reinit()] - # Extruders: 0
2023-11-23 15:59:52,481 [printer.py:reinit()] - # Temperature devices: 0
2023-11-23 15:59:52,482 [printer.py:reinit()] - # Fans: 0
2023-11-23 15:59:52,483 [printer.py:reinit()] - # Output pins: 0
2023-11-23 15:59:52,483 [printer.py:reinit()] - # Leds: 0
2023-11-23 15:59:52,529 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-23 15:59:52,532 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-23 15:59:52,736 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe
2023-11-23 15:59:52,738 [files.py:initialize()] - Gcodes path: None
2023-11-23 15:59:52,739 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-23 15:59:52,741 [screen.py:init_printer()] - Printer initialized
2023-11-23 15:59:52,742 [printer.py:change_state()] - Changing state from 'disconnected' to 'error'
2023-11-23 15:59:52,742 [printer.py:change_state()] - Adding callback for state: error
2023-11-23 15:59:52,751 [screen.py:show_panel()] - Reinitializing panel
2023-11-23 15:59:52,848 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-23 16:00:00,088 [KlippyWebsocket.py:restart_firmware()] - Sending printer.firmware_restart
2023-11-23 16:00:00,111 [printer.py:change_state()] - Changing state from 'error' to 'disconnected'
2023-11-23 16:00:00,111 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-23 16:00:00,113 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-23 16:00:00,116 [screen.py:show_panel()] - Reinitializing panel
2023-11-23 16:00:00,208 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-23 16:00:03,840 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-23 16:00:03,873 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-23 16:00:03,876 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'error', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'update_manager', 'history', 'authorization'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-23 16:00:03,932 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-23 16:00:03,935 [printer.py:configure_cameras()] - Cameras: []
2023-11-23 16:00:03,963 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-23 16:00:04,151 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-23 16:00:04,160 [screen.py:init_printer()] - {'configfile': {'config': {}, 'settings': {}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-23 16:00:04,161 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1-dirty
2023-11-23 16:00:04,161 [printer.py:reinit()] - # Extruders: 0
2023-11-23 16:00:04,162 [printer.py:reinit()] - # Temperature devices: 0
2023-11-23 16:00:04,162 [printer.py:reinit()] - # Fans: 0
2023-11-23 16:00:04,163 [printer.py:reinit()] - # Output pins: 0
2023-11-23 16:00:04,164 [printer.py:reinit()] - # Leds: 0
2023-11-23 16:00:04,199 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-23 16:00:04,201 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-23 16:00:04,555 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe
2023-11-23 16:00:04,560 [files.py:initialize()] - Gcodes path: None
2023-11-23 16:00:04,560 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-23 16:00:04,566 [screen.py:init_printer()] - Printer initialized
2023-11-23 16:00:04,567 [printer.py:change_state()] - Changing state from 'disconnected' to 'error'
2023-11-23 16:00:04,568 [printer.py:change_state()] - Adding callback for state: error
2023-11-23 16:00:04,584 [screen.py:show_panel()] - Reinitializing panel
2023-11-23 16:00:04,702 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-23 16:01:18,850 [printer.py:change_state()] - Changing state from 'error' to 'disconnected'
2023-11-23 16:01:18,851 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-23 16:01:18,853 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-23 16:01:18,856 [screen.py:show_panel()] - Reinitializing panel
2023-11-23 16:01:18,943 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-23 16:01:22,252 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-23 16:01:22,276 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-23 16:01:22,278 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'update_manager', 'history', 'authorization'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-23 16:01:22,301 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-23 16:01:22,303 [printer.py:configure_cameras()] - Cameras: []
2023-11-23 16:01:23,645 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-23 16:01:23,718 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-23 16:01:23,723 [screen.py:init_printer()] - {'configfile': {'config': {'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': '2.', 'verbose': 'True'}, 'gcode_macro HELLO_WORLD': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world'}, 'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '23.940', 'pid_ki': '1.629', 'pid_kd': '87.981'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'min_temp': '0', 'max_temp': '130', 'control': 'pid', 'pid_kp': '69.445', 'pid_ki': '1.146', 'pid_kd': '1052.087'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5', 'z_offset': '-0.230'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'exclude_object': {}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': '90.0', 'verbose': 'True'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': 2.0, 'verbose': True}, 'gcode_macro hello_world': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world', 'description': 'G-Code macro'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 23.94, 'pid_ki': 1.629, 'pid_kd': 87.981, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 69.445, 'pid_ki': 1.146, 'pid_kd': 1052.087, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': -0.23, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script', 'description': 'G-Code macro'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': 90.0, 'verbose': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-23 16:01:23,728 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1-dirty
2023-11-23 16:01:23,728 [printer.py:reinit()] - # Extruders: 1
2023-11-23 16:01:23,729 [printer.py:reinit()] - # Temperature devices: 1
2023-11-23 16:01:23,729 [printer.py:reinit()] - # Fans: 1
2023-11-23 16:01:23,730 [printer.py:reinit()] - # Output pins: 0
2023-11-23 16:01:23,730 [printer.py:reinit()] - # Leds: 0
2023-11-23 16:01:23,758 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-23 16:01:23,761 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-23 16:01:24,032 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-11-23 16:01:24,070 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-23 16:01:24,073 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-11-23 16:01:24,074 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-23 16:01:24,074 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-23 16:01:24,076 [screen.py:init_printer()] - Printer initialized
2023-11-23 16:01:24,077 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-23 16:01:24,078 [printer.py:change_state()] - Adding callback for state: startup
2023-11-23 16:01:24,947 [printer.py:change_state()] - Changing state from 'startup' to 'error'
2023-11-23 16:01:24,948 [printer.py:change_state()] - Adding callback for state: error
2023-11-23 16:01:24,952 [screen.py:show_panel()] - Reinitializing panel
2023-11-23 16:01:25,056 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-23 16:01:29,250 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-23 16:01:29,252 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-11-23 16:01:31,864 [KlippyWebsocket.py:restart_firmware()] - Sending printer.firmware_restart
2023-11-23 16:01:31,906 [printer.py:change_state()] - Changing state from 'error' to 'disconnected'
2023-11-23 16:01:31,907 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-23 16:01:31,909 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-23 16:01:31,912 [screen.py:show_panel()] - Reinitializing panel
2023-11-23 16:01:31,999 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-23 16:01:34,251 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-23 16:01:34,253 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-11-23 16:01:35,251 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-23 16:01:35,274 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-23 16:01:35,277 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'update_manager', 'history', 'authorization'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-23 16:01:35,299 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-23 16:01:35,303 [printer.py:configure_cameras()] - Cameras: []
2023-11-23 16:01:36,270 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-23 16:01:36,315 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-23 16:01:36,321 [screen.py:init_printer()] - {'configfile': {'config': {'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': '2.', 'verbose': 'True'}, 'gcode_macro HELLO_WORLD': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world'}, 'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '23.940', 'pid_ki': '1.629', 'pid_kd': '87.981'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'min_temp': '0', 'max_temp': '130', 'control': 'pid', 'pid_kp': '69.445', 'pid_ki': '1.146', 'pid_kd': '1052.087'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5', 'z_offset': '-0.230'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'exclude_object': {}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': '90.0', 'verbose': 'True'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': 2.0, 'verbose': True}, 'gcode_macro hello_world': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world', 'description': 'G-Code macro'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 23.94, 'pid_ki': 1.629, 'pid_kd': 87.981, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 69.445, 'pid_ki': 1.146, 'pid_kd': 1052.087, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': -0.23, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script', 'description': 'G-Code macro'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': 90.0, 'verbose': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-23 16:01:36,327 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1-dirty
2023-11-23 16:01:36,328 [printer.py:reinit()] - # Extruders: 1
2023-11-23 16:01:36,328 [printer.py:reinit()] - # Temperature devices: 1
2023-11-23 16:01:36,329 [printer.py:reinit()] - # Fans: 1
2023-11-23 16:01:36,329 [printer.py:reinit()] - # Output pins: 0
2023-11-23 16:01:36,330 [printer.py:reinit()] - # Leds: 0
2023-11-23 16:01:36,358 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-23 16:01:36,361 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-23 16:01:36,636 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-11-23 16:01:36,671 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-23 16:01:36,674 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-11-23 16:01:36,675 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-23 16:01:36,675 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-23 16:01:36,677 [screen.py:init_printer()] - Printer initialized
2023-11-23 16:01:36,678 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-23 16:01:36,678 [printer.py:change_state()] - Adding callback for state: startup
2023-11-23 16:01:38,074 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-23 16:01:38,075 [printer.py:change_state()] - Adding callback for state: ready
2023-11-23 16:01:38,082 [screen.py:_load_panel()] - Loading panel: main_menu
2023-11-23 16:01:38,253 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-23 16:01:38,268 [main_menu.py:add_device()] - Adding device: extruder
2023-11-23 16:01:38,281 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-23 16:01:38,371 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-23 16:01:38,376 [main_menu.py:update_graph_visibility()] - Could not create graph tempstore: []
2023-11-23 16:01:39,252 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-23 16:01:39,254 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-11-23 16:01:42,249 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-23 16:01:42,275 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-11-23 16:01:42,300 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-23 16:01:42,302 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-23 16:01:44,250 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-23 16:01:44,276 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-11-23 16:01:44,301 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-23 16:01:44,304 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-27 14:19:00,157 [functions.py:log_start()] - --------------------KlipperScreen Log Start--------------------
2023-11-27 14:19:00,158 [functions.py:log_start()] - KlipperScreen Version: v0.3.6-85-gad3b935
2023-11-27 14:19:00,159 [functions.py:log_start()] - Python version: 3.9
2023-11-27 14:19:00,503 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-11-27 14:19:00,505 [config.py:__init__()] - Config path location: /home/biqu/printer_data/config/KlipperScreen.conf
2023-11-27 14:19:00,551 [config.py:log_config()] -  ===== Config File =====

=======================
2023-11-27 14:19:00,556 [config.py:__init__()] - ====== Saved Def ======

[graph Printer]
extruder = False

=======================
2023-11-27 14:19:00,558 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-11-27 14:19:00,719 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-11-27 14:19:00,721 [config.py:install_language()] - Using system lang
2023-11-27 14:19:00,724 [config.py:install_language()] - Using lang en
2023-11-27 14:19:00,778 [screen.py:__init__()] - Screen resolution: 1024x600
2023-11-27 14:19:00,782 [KlippyGtk.py:__init__()] - Font size: 20.7 (medium)
2023-11-27 14:19:02,112 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-11-27 14:19:02,131 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-11-27 14:19:02,145 [screen.py:initial_connection()] - Default printer: None
2023-11-27 14:19:02,146 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-11-27 14:19:02,147 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-11-27 14:19:02,265 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-27 14:19:02,286 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-11-27 14:19:02,327 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-27 14:19:02,354 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-11-27 14:19:02,357 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-11-27 14:19:02,378 [_logging.py:info()] - Websocket connected
2023-11-27 14:19:02,381 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-11-27 14:19:02,459 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-27 14:19:02,483 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-27 14:19:02,485 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'ready', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'update_manager', 'authorization', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-11-27 14:19:02,509 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-27 14:19:02,511 [printer.py:configure_cameras()] - Cameras: []
2023-11-27 14:19:02,539 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-27 14:19:02,626 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-27 14:19:02,631 [screen.py:init_printer()] - {'configfile': {'config': {'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': '2.', 'verbose': 'True'}, 'gcode_macro HELLO_WORLD': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world'}, 'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '23.940', 'pid_ki': '1.629', 'pid_kd': '87.981'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'min_temp': '0', 'max_temp': '130', 'control': 'pid', 'pid_kp': '69.445', 'pid_ki': '1.146', 'pid_kd': '1052.087'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5', 'z_offset': '-0.230'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'exclude_object': {}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': '90.0', 'verbose': 'True'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': 2.0, 'verbose': True}, 'gcode_macro hello_world': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world', 'description': 'G-Code macro'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 23.94, 'pid_ki': 1.629, 'pid_kd': 87.981, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 69.445, 'pid_ki': 1.146, 'pid_kd': 1052.087, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': -0.23, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script', 'description': 'G-Code macro'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': 90.0, 'verbose': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-27 14:19:02,636 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1-dirty
2023-11-27 14:19:02,636 [printer.py:reinit()] - # Extruders: 1
2023-11-27 14:19:02,637 [printer.py:reinit()] - # Temperature devices: 1
2023-11-27 14:19:02,637 [printer.py:reinit()] - # Fans: 1
2023-11-27 14:19:02,638 [printer.py:reinit()] - # Output pins: 0
2023-11-27 14:19:02,638 [printer.py:reinit()] - # Leds: 0
2023-11-27 14:19:02,674 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-27 14:19:02,678 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-27 14:19:02,962 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-11-27 14:19:02,998 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-27 14:19:03,024 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-11-27 14:19:03,050 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-27 14:19:03,053 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-27 14:19:03,054 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-27 14:19:03,054 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-27 14:19:03,056 [screen.py:init_printer()] - Printer initialized
2023-11-27 14:19:03,057 [printer.py:change_state()] - Changing state from 'disconnected' to 'ready'
2023-11-27 14:19:03,058 [printer.py:change_state()] - Adding callback for state: ready
2023-11-27 14:19:03,075 [screen.py:_load_panel()] - Loading panel: main_menu
2023-11-27 14:19:03,256 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-27 14:19:03,274 [main_menu.py:add_device()] - Adding device: extruder
2023-11-27 14:19:03,288 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-27 14:19:03,359 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-27 14:19:11,224 [screen.py:_load_panel()] - Loading panel: move
2023-11-27 14:19:11,397 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > move
2023-11-27 14:19:12,692 [screen.py:_load_panel()] - Loading panel: menu
2023-11-27 14:19:12,963 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > move > menu
2023-11-27 14:19:13,001 [menu.py:arrangeMenuItems()] - X > homing quad_gantry_level
2023-11-27 14:19:13,011 [menu.py:arrangeMenuItems()] - X > homing Z-Tilt
2023-11-27 14:19:15,118 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G28'}
2023-11-27 14:19:36,965 [screen.py:_menu_go_back()] - #### Menu go back
2023-11-27 14:19:37,010 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > move
2023-11-27 14:19:42,342 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 Z+25 F600'}
2023-11-27 14:19:42,351 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-27 14:19:46,309 [move.py:change_distance()] - ### Distance 50
2023-11-27 14:19:48,318 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 Z+50 F600'}
2023-11-27 14:19:48,324 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-27 14:19:49,294 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 Z+50 F600'}
2023-11-27 14:19:49,300 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-27 14:20:11,831 [screen.py:_menu_go_back()] - #### Menu go back
2023-11-27 14:20:11,883 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-27 14:20:21,477 [main_menu.py:verify_max_temp()] - 40/130
2023-11-27 14:20:21,478 [KlippyWebsocket.py:set_bed_temp()] - Sending set_bed_temp: M140 S40
2023-11-27 14:20:59,926 [main_menu.py:toggle_visibility()] - Graph show False: heater_bed
2023-11-27 14:21:05,166 [main_menu.py:verify_max_temp()] - 55/130
2023-11-27 14:21:05,166 [KlippyWebsocket.py:set_bed_temp()] - Sending set_bed_temp: M140 S55
2023-11-27 14:22:29,789 [screen.py:_go_to_submenu()] - #### Go to submenu more
2023-11-27 14:22:29,790 [screen.py:_go_to_submenu()] - #### Menu __main
2023-11-27 14:22:29,801 [screen.py:_load_panel()] - Loading panel: menu
2023-11-27 14:22:30,291 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > more
2023-11-27 14:22:30,302 [menu.py:arrangeMenuItems()] - X > more bedlevel
2023-11-27 14:22:30,322 [menu.py:arrangeMenuItems()] - X > more retraction
2023-11-27 14:22:30,337 [menu.py:arrangeMenuItems()] - X > more led
2023-11-27 14:22:30,352 [menu.py:arrangeMenuItems()] - X > more pins
2023-11-27 14:22:30,360 [menu.py:arrangeMenuItems()] - X > more power
2023-11-27 14:22:30,368 [menu.py:arrangeMenuItems()] - X > more camera
2023-11-27 14:22:30,381 [menu.py:arrangeMenuItems()] - X > more input_shaper
2023-11-27 14:22:30,402 [menu.py:arrangeMenuItems()] - X > more spoolman
2023-11-27 14:22:36,712 [screen.py:_load_panel()] - Loading panel: fan
2023-11-27 14:22:36,722 [fan.py:add_fan()] - Adding fan: fan
2023-11-27 14:22:36,780 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > more > fan
2023-11-27 14:22:38,486 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: M106 S0
2023-11-27 14:22:42,133 [screen.py:_menu_go_back()] - #### Menu go back
2023-11-27 14:22:42,176 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > more
2023-11-27 14:22:42,199 [menu.py:arrangeMenuItems()] - X > more bedlevel
2023-11-27 14:22:42,219 [menu.py:arrangeMenuItems()] - X > more retraction
2023-11-27 14:22:42,234 [menu.py:arrangeMenuItems()] - X > more led
2023-11-27 14:22:42,250 [menu.py:arrangeMenuItems()] - X > more pins
2023-11-27 14:22:42,259 [menu.py:arrangeMenuItems()] - X > more power
2023-11-27 14:22:42,267 [menu.py:arrangeMenuItems()] - X > more camera
2023-11-27 14:22:42,280 [menu.py:arrangeMenuItems()] - X > more input_shaper
2023-11-27 14:22:42,301 [menu.py:arrangeMenuItems()] - X > more spoolman
2023-11-27 14:22:42,957 [screen.py:_menu_go_back()] - #### Menu go back
2023-11-27 14:22:42,999 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-27 14:42:43,122 [main_menu.py:verify_max_temp()] - 55/130
2023-11-27 14:42:43,122 [KlippyWebsocket.py:set_bed_temp()] - Sending set_bed_temp: M140 S55
2023-11-27 15:00:58,656 [main_menu.py:toggle_visibility()] - Graph show True: heater_bed
2023-11-27 15:01:12,384 [main_menu.py:verify_max_temp()] - 55/130
2023-11-27 15:01:12,385 [KlippyWebsocket.py:set_bed_temp()] - Sending set_bed_temp: M140 S55
2023-11-27 15:36:54,854 [main_menu.py:verify_max_temp()] - 55/130
2023-11-27 15:36:54,855 [KlippyWebsocket.py:set_bed_temp()] - Sending set_bed_temp: M140 S55
2023-11-27 16:24:50,917 [main_menu.py:verify_max_temp()] - 55/130
2023-11-27 16:24:50,917 [KlippyWebsocket.py:set_bed_temp()] - Sending set_bed_temp: M140 S55
2023-12-02 13:32:22,333 [functions.py:log_start()] - --------------------KlipperScreen Log Start--------------------
2023-12-02 13:32:22,334 [functions.py:log_start()] - KlipperScreen Version: v0.3.6-85-gad3b935
2023-12-02 13:32:22,335 [functions.py:log_start()] - Python version: 3.9
2023-12-02 13:32:22,782 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-12-02 13:32:22,786 [config.py:__init__()] - Config path location: /home/biqu/printer_data/config/KlipperScreen.conf
2023-12-02 13:32:22,851 [config.py:log_config()] -  ===== Config File =====

=======================
2023-12-02 13:32:22,859 [config.py:__init__()] - ====== Saved Def ======

[graph Printer]
extruder = False

=======================
2023-12-02 13:32:22,861 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-12-02 13:32:23,040 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-12-02 13:32:23,041 [config.py:install_language()] - Using system lang
2023-12-02 13:32:23,043 [config.py:install_language()] - Using lang en
2023-12-02 13:32:23,108 [screen.py:__init__()] - Screen resolution: 1024x600
2023-12-02 13:32:23,116 [KlippyGtk.py:__init__()] - Font size: 20.7 (medium)
2023-12-02 13:32:25,060 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-12-02 13:32:25,082 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-12-02 13:32:25,104 [screen.py:initial_connection()] - Default printer: None
2023-12-02 13:32:25,105 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-12-02 13:32:25,106 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-12-02 13:32:25,236 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-12-02 13:32:25,273 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-12-02 13:32:25,366 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 13:32:25,404 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-12-02 13:32:25,407 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-12-02 13:32:25,456 [_logging.py:info()] - Websocket connected
2023-12-02 13:32:25,457 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-12-02 13:32:25,548 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 13:32:25,588 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 13:32:25,591 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'authorization', 'history', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-12-02 13:32:25,617 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-02 13:32:25,620 [printer.py:configure_cameras()] - Cameras: []
2023-12-02 13:32:25,661 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-12-02 13:32:25,869 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-12-02 13:32:25,874 [screen.py:init_printer()] - {'configfile': {'config': {'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': '2.', 'verbose': 'True'}, 'gcode_macro HELLO_WORLD': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world'}, 'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '23.940', 'pid_ki': '1.629', 'pid_kd': '87.981'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'min_temp': '0', 'max_temp': '130', 'control': 'pid', 'pid_kp': '69.445', 'pid_ki': '1.146', 'pid_kd': '1052.087'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5', 'z_offset': '-0.230'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'exclude_object': {}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': '90.0', 'verbose': 'True'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': 2.0, 'verbose': True}, 'gcode_macro hello_world': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world', 'description': 'G-Code macro'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 23.94, 'pid_ki': 1.629, 'pid_kd': 87.981, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 69.445, 'pid_ki': 1.146, 'pid_kd': 1052.087, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': -0.23, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script', 'description': 'G-Code macro'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': 90.0, 'verbose': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-12-02 13:32:25,880 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1-dirty
2023-12-02 13:32:25,881 [printer.py:reinit()] - # Extruders: 1
2023-12-02 13:32:25,882 [printer.py:reinit()] - # Temperature devices: 1
2023-12-02 13:32:25,882 [printer.py:reinit()] - # Fans: 1
2023-12-02 13:32:25,883 [printer.py:reinit()] - # Output pins: 0
2023-12-02 13:32:25,883 [printer.py:reinit()] - # Leds: 0
2023-12-02 13:32:25,924 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-12-02 13:32:25,929 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-12-02 13:32:26,203 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-12-02 13:32:26,233 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-12-02 13:32:26,235 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-12-02 13:32:26,237 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-12-02 13:32:26,237 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-12-02 13:32:26,239 [screen.py:init_printer()] - Printer initialized
2023-12-02 13:32:26,240 [printer.py:change_state()] - Changing state from 'disconnected' to 'ready'
2023-12-02 13:32:26,241 [printer.py:change_state()] - Adding callback for state: ready
2023-12-02 13:32:26,249 [screen.py:_load_panel()] - Loading panel: main_menu
2023-12-02 13:32:26,446 [main_menu.py:__init__()] - ### Making MainMenu
2023-12-02 13:32:26,463 [main_menu.py:add_device()] - Adding device: extruder
2023-12-02 13:32:26,476 [main_menu.py:add_device()] - Adding device: heater_bed
2023-12-02 13:32:26,544 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-12-02 13:32:26,547 [main_menu.py:update_graph_visibility()] - Could not create graph tempstore: []
2023-12-02 13:32:31,662 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-12-02 13:32:31,689 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-12-02 13:32:31,720 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-12-02 13:32:31,722 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-12-02 13:32:49,097 [screen.py:_go_to_submenu()] - #### Go to submenu more
2023-12-02 13:32:49,098 [screen.py:_go_to_submenu()] - #### Menu __main
2023-12-02 13:32:49,110 [screen.py:_load_panel()] - Loading panel: menu
2023-12-02 13:32:49,675 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > more
2023-12-02 13:32:49,689 [menu.py:arrangeMenuItems()] - X > more bedlevel
2023-12-02 13:32:49,712 [menu.py:arrangeMenuItems()] - X > more retraction
2023-12-02 13:32:49,731 [menu.py:arrangeMenuItems()] - X > more led
2023-12-02 13:32:49,749 [menu.py:arrangeMenuItems()] - X > more pins
2023-12-02 13:32:49,757 [menu.py:arrangeMenuItems()] - X > more power
2023-12-02 13:32:49,767 [menu.py:arrangeMenuItems()] - X > more camera
2023-12-02 13:32:49,782 [menu.py:arrangeMenuItems()] - X > more input_shaper
2023-12-02 13:32:49,806 [menu.py:arrangeMenuItems()] - X > more spoolman
2023-12-02 13:32:57,044 [screen.py:_load_panel()] - Loading panel: settings
2023-12-02 13:32:57,452 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > more > settings
2023-12-02 13:33:24,745 [screen.py:_menu_go_back()] - #### Menu go back
2023-12-02 13:33:24,800 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > more
2023-12-02 13:33:24,813 [menu.py:arrangeMenuItems()] - X > more bedlevel
2023-12-02 13:33:24,833 [menu.py:arrangeMenuItems()] - X > more retraction
2023-12-02 13:33:24,849 [menu.py:arrangeMenuItems()] - X > more led
2023-12-02 13:33:24,864 [menu.py:arrangeMenuItems()] - X > more pins
2023-12-02 13:33:24,871 [menu.py:arrangeMenuItems()] - X > more power
2023-12-02 13:33:24,879 [menu.py:arrangeMenuItems()] - X > more camera
2023-12-02 13:33:24,893 [menu.py:arrangeMenuItems()] - X > more input_shaper
2023-12-02 13:33:24,913 [menu.py:arrangeMenuItems()] - X > more spoolman
2023-12-02 13:33:59,532 [screen.py:_load_panel()] - Loading panel: gcode_macros
2023-12-02 13:33:59,612 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > more > gcode_macros
2023-12-02 13:34:04,801 [screen.py:_menu_go_back()] - #### Menu go back
2023-12-02 13:34:04,854 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > more
2023-12-02 13:34:04,868 [menu.py:arrangeMenuItems()] - X > more bedlevel
2023-12-02 13:34:04,891 [menu.py:arrangeMenuItems()] - X > more retraction
2023-12-02 13:34:04,906 [menu.py:arrangeMenuItems()] - X > more led
2023-12-02 13:34:04,921 [menu.py:arrangeMenuItems()] - X > more pins
2023-12-02 13:34:04,929 [menu.py:arrangeMenuItems()] - X > more power
2023-12-02 13:34:04,938 [menu.py:arrangeMenuItems()] - X > more camera
2023-12-02 13:34:04,953 [menu.py:arrangeMenuItems()] - X > more input_shaper
2023-12-02 13:34:04,974 [menu.py:arrangeMenuItems()] - X > more spoolman
2023-12-02 13:34:05,817 [screen.py:_menu_go_back()] - #### Menu go home
2023-12-02 13:34:05,870 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-12-02 13:34:20,865 [screen.py:_go_to_submenu()] - #### Go to submenu more
2023-12-02 13:34:20,866 [screen.py:_go_to_submenu()] - #### Menu __main
2023-12-02 13:34:20,920 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > more
2023-12-02 13:34:20,933 [menu.py:arrangeMenuItems()] - X > more bedlevel
2023-12-02 13:34:20,953 [menu.py:arrangeMenuItems()] - X > more retraction
2023-12-02 13:34:20,970 [menu.py:arrangeMenuItems()] - X > more led
2023-12-02 13:34:20,987 [menu.py:arrangeMenuItems()] - X > more pins
2023-12-02 13:34:20,995 [menu.py:arrangeMenuItems()] - X > more power
2023-12-02 13:34:21,003 [menu.py:arrangeMenuItems()] - X > more camera
2023-12-02 13:34:21,017 [menu.py:arrangeMenuItems()] - X > more input_shaper
2023-12-02 13:34:21,039 [menu.py:arrangeMenuItems()] - X > more spoolman
2023-12-02 13:34:29,498 [screen.py:_menu_go_back()] - #### Menu go back
2023-12-02 13:34:29,547 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-12-02 13:34:31,635 [screen.py:_load_panel()] - Loading panel: move
2023-12-02 13:34:31,810 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > move
2023-12-02 13:34:33,695 [screen.py:_load_panel()] - Loading panel: menu
2023-12-02 13:34:33,938 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > move > menu
2023-12-02 13:34:33,966 [menu.py:arrangeMenuItems()] - X > homing quad_gantry_level
2023-12-02 13:34:33,974 [menu.py:arrangeMenuItems()] - X > homing Z-Tilt
2023-12-02 13:34:36,217 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G28 X'}
2023-12-02 13:34:42,249 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G28 Y'}
2023-12-02 13:34:49,209 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G28 Z'}
2023-12-02 13:35:43,625 [screen.py:_menu_go_back()] - #### Menu go back
2023-12-02 13:35:43,670 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > move
2023-12-02 13:35:46,969 [screen.py:_menu_go_back()] - #### Menu go back
2023-12-02 13:35:47,013 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-12-02 13:47:16,947 [printer.py:change_state()] - Changing state from 'ready' to 'disconnected'
2023-12-02 13:47:16,947 [printer.py:change_state()] - Adding callback for state: disconnected
2023-12-02 13:47:16,950 [screen.py:state_disconnected()] - ### Going to disconnected
2023-12-02 13:47:16,954 [screen.py:show_panel()] - Reinitializing panel
2023-12-02 13:47:17,043 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-12-02 13:47:20,660 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 13:47:20,685 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 13:47:20,687 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'error', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'authorization', 'history', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-12-02 13:47:20,711 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-02 13:47:20,713 [printer.py:configure_cameras()] - Cameras: []
2023-12-02 13:47:20,741 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-12-02 13:47:20,891 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-12-02 13:47:20,893 [screen.py:init_printer()] - {'configfile': {'config': {}, 'settings': {}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-12-02 13:47:20,895 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1-dirty
2023-12-02 13:47:20,895 [printer.py:reinit()] - # Extruders: 0
2023-12-02 13:47:20,896 [printer.py:reinit()] - # Temperature devices: 0
2023-12-02 13:47:20,896 [printer.py:reinit()] - # Fans: 0
2023-12-02 13:47:20,896 [printer.py:reinit()] - # Output pins: 0
2023-12-02 13:47:20,897 [printer.py:reinit()] - # Leds: 0
2023-12-02 13:47:20,922 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-12-02 13:47:20,925 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-12-02 13:47:21,150 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe
2023-12-02 13:47:21,152 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-12-02 13:47:21,153 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-12-02 13:47:21,154 [screen.py:init_printer()] - Printer initialized
2023-12-02 13:47:21,155 [printer.py:change_state()] - Changing state from 'disconnected' to 'error'
2023-12-02 13:47:21,156 [printer.py:change_state()] - Adding callback for state: error
2023-12-02 13:47:21,162 [screen.py:show_panel()] - Reinitializing panel
2023-12-02 13:47:21,253 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-12-02 13:48:07,992 [KlippyWebsocket.py:restart_firmware()] - Sending printer.firmware_restart
2023-12-02 13:48:08,011 [printer.py:change_state()] - Changing state from 'error' to 'disconnected'
2023-12-02 13:48:08,012 [printer.py:change_state()] - Adding callback for state: disconnected
2023-12-02 13:48:08,017 [screen.py:state_disconnected()] - ### Going to disconnected
2023-12-02 13:48:08,021 [screen.py:show_panel()] - Reinitializing panel
2023-12-02 13:48:08,110 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-12-02 13:48:11,658 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 13:48:11,680 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 13:48:11,682 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'error', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'authorization', 'history', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-12-02 13:48:11,703 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-02 13:48:11,705 [printer.py:configure_cameras()] - Cameras: []
2023-12-02 13:48:11,733 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-12-02 13:48:11,957 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-12-02 13:48:11,959 [screen.py:init_printer()] - {'configfile': {'config': {}, 'settings': {}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-12-02 13:48:11,959 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1-dirty
2023-12-02 13:48:11,960 [printer.py:reinit()] - # Extruders: 0
2023-12-02 13:48:11,960 [printer.py:reinit()] - # Temperature devices: 0
2023-12-02 13:48:11,960 [printer.py:reinit()] - # Fans: 0
2023-12-02 13:48:11,961 [printer.py:reinit()] - # Output pins: 0
2023-12-02 13:48:11,961 [printer.py:reinit()] - # Leds: 0
2023-12-02 13:48:11,986 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-12-02 13:48:11,988 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-12-02 13:48:12,215 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe
2023-12-02 13:48:12,217 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-12-02 13:48:12,218 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-12-02 13:48:12,220 [screen.py:init_printer()] - Printer initialized
2023-12-02 13:48:12,220 [printer.py:change_state()] - Changing state from 'disconnected' to 'error'
2023-12-02 13:48:12,221 [printer.py:change_state()] - Adding callback for state: error
2023-12-02 13:48:12,226 [screen.py:show_panel()] - Reinitializing panel
2023-12-02 13:48:12,322 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-12-02 13:49:09,732 [functions.py:log_start()] - --------------------KlipperScreen Log Start--------------------
2023-12-02 13:49:09,733 [functions.py:log_start()] - KlipperScreen Version: v0.3.6-85-gad3b935
2023-12-02 13:49:09,734 [functions.py:log_start()] - Python version: 3.9
2023-12-02 13:49:10,376 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-12-02 13:49:10,378 [config.py:__init__()] - Config path location: /home/biqu/printer_data/config/KlipperScreen.conf
2023-12-02 13:49:10,474 [config.py:log_config()] -  ===== Config File =====

=======================
2023-12-02 13:49:10,482 [config.py:__init__()] - ====== Saved Def ======

[graph Printer]
extruder = False

=======================
2023-12-02 13:49:10,484 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-12-02 13:49:10,644 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-12-02 13:49:10,645 [config.py:install_language()] - Using system lang
2023-12-02 13:49:10,646 [config.py:install_language()] - Using lang en
2023-12-02 13:49:10,693 [screen.py:__init__()] - Screen resolution: 1024x600
2023-12-02 13:49:10,697 [KlippyGtk.py:__init__()] - Font size: 20.7 (medium)
2023-12-02 13:49:13,592 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-12-02 13:49:13,607 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-12-02 13:49:13,619 [screen.py:initial_connection()] - Default printer: None
2023-12-02 13:49:13,620 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-12-02 13:49:13,621 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-12-02 13:49:13,728 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-12-02 13:49:13,748 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-12-02 13:49:13,791 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 13:49:13,816 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-12-02 13:49:13,818 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-12-02 13:49:13,836 [_logging.py:info()] - Websocket connected
2023-12-02 13:49:13,837 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-12-02 13:49:13,921 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 13:49:13,944 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 13:49:13,946 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'octoprint_compat', 'authorization', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-12-02 13:49:13,969 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-02 13:49:13,971 [printer.py:configure_cameras()] - Cameras: []
2023-12-02 13:49:13,971 [screen.py:init_printer()] - Klipper not connected
2023-12-02 13:49:17,614 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 13:49:17,638 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 13:49:17,641 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'octoprint_compat', 'authorization', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-12-02 13:49:17,662 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-02 13:49:17,664 [printer.py:configure_cameras()] - Cameras: []
2023-12-02 13:49:17,665 [screen.py:init_printer()] - Klipper not connected
2023-12-02 13:49:20,613 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 13:49:20,635 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 13:49:20,637 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'error', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'octoprint_compat', 'authorization', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-12-02 13:49:20,658 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-02 13:49:20,660 [printer.py:configure_cameras()] - Cameras: []
2023-12-02 13:49:20,685 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-12-02 13:49:20,749 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-12-02 13:49:20,751 [screen.py:init_printer()] - {'configfile': {'config': {}, 'settings': {}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-12-02 13:49:20,752 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1-dirty
2023-12-02 13:49:20,753 [printer.py:reinit()] - # Extruders: 0
2023-12-02 13:49:20,753 [printer.py:reinit()] - # Temperature devices: 0
2023-12-02 13:49:20,754 [printer.py:reinit()] - # Fans: 0
2023-12-02 13:49:20,754 [printer.py:reinit()] - # Output pins: 0
2023-12-02 13:49:20,754 [printer.py:reinit()] - # Leds: 0
2023-12-02 13:49:20,779 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-12-02 13:49:20,782 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-12-02 13:49:21,008 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe
2023-12-02 13:49:21,011 [files.py:initialize()] - Gcodes path: None
2023-12-02 13:49:21,011 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-12-02 13:49:21,013 [screen.py:init_printer()] - Printer initialized
2023-12-02 13:49:21,013 [printer.py:change_state()] - Changing state from 'disconnected' to 'error'
2023-12-02 13:49:21,014 [printer.py:change_state()] - Adding callback for state: error
2023-12-02 13:49:21,019 [screen.py:show_panel()] - Reinitializing panel
2023-12-02 13:49:21,111 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-12-02 13:50:27,174 [printer.py:change_state()] - Changing state from 'error' to 'disconnected'
2023-12-02 13:50:27,175 [printer.py:change_state()] - Adding callback for state: disconnected
2023-12-02 13:50:27,176 [screen.py:state_disconnected()] - ### Going to disconnected
2023-12-02 13:50:27,179 [screen.py:show_panel()] - Reinitializing panel
2023-12-02 13:50:27,269 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-12-02 13:50:30,617 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 13:50:30,649 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 13:50:30,651 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'octoprint_compat', 'authorization', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-202-gdddd968', 'missing_klippy_requirements': [], 'api_version': [1, 4, 0], 'api_version_string': '1.4.0'}
2023-12-02 13:50:30,805 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-02 13:50:30,810 [printer.py:configure_cameras()] - Cameras: []
2023-12-02 13:50:32,139 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-12-02 13:50:32,215 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-12-02 13:50:32,219 [screen.py:init_printer()] - {'configfile': {'config': {'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': '2.', 'verbose': 'True'}, 'gcode_macro HELLO_WORLD': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world'}, 'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'restart_method': 'command'}, 'virtual_sdcard': {'path': '/home/biqu/SV06_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}'}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'stepper_x': {'step_pin': 'PC2', 'dir_pin': '!PB9', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'run_current': '0.860', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '81', 'diag_pin': 'PA5'}, 'stepper_y': {'step_pin': 'PB8', 'dir_pin': 'PB7', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': '0', 'position_max': '225', 'homing_speed': '40', 'homing_retract_dist': '0'}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'run_current': '0.900', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'driver_sgthrs': '82', 'diag_pin': 'PA6'}, 'stepper_z': {'step_pin': 'PB6', 'dir_pin': '!PB5', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': '-4', 'position_max': '261', 'homing_speed': '4'}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'run_current': '1.000', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3', 'diag_pin': 'PA7'}, 'extruder': {'max_extrude_only_distance': '100.0', 'step_pin': 'PB4', 'dir_pin': '!PB3', 'enable_pin': '!PC3', 'microsteps': '16', 'rotation_distance': '4.56', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PA1', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC5', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '23.940', 'pid_ki': '1.629', 'pid_kd': '87.981'}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'run_current': '0.550', 'stealthchop_threshold': '0', 'interpolate': 'False', 'sense_resistor': '0.150', 'uart_address': '3'}, 'heater_bed': {'heater_pin': 'PA2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PC4', 'min_temp': '0', 'max_temp': '130', 'control': 'pid', 'pid_kp': '69.445', 'pid_ki': '1.146', 'pid_kd': '1052.087'}, 'fan': {'pin': 'PA0'}, 'probe': {'pin': 'PB1', 'x_offset': '28', 'y_offset': '-20', 'samples': '2', 'samples_tolerance': '0.015', 'samples_tolerance_retries': '5', 'z_offset': '-0.230'}, 'safe_z_home': {'home_xy_position': '85,135', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'horizontal_move_z': '5', 'mesh_min': '28, 20', 'mesh_max': '210, 205', 'probe_count': '10', 'algorithm': 'bicubic', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0'}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'encoder_pins': '^PB14, ^PB10', 'click_pin': '^!PB2'}, 'exclude_object': {}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': '90.0', 'verbose': 'True'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-path/platform-5200000.usb-usb-0:1.3:1.0-port0', 'baud': 250000, 'restart_method': 'command', 'max_stepper_error': 2.5e-05}, 'gcode_shell_command hello_world': {'command': 'echo hello world', 'timeout': 2.0, 'verbose': True}, 'gcode_macro hello_world': {'gcode': '\nRUN_SHELL_COMMAND CMD=hello_world', 'description': 'G-Code macro'}, 'virtual_sdcard': {'path': '/home/biqu/SV06_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro RESUME\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro RESUME\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n{client.user_cancel_macro|default("")}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0 %}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n{client.user_pause_macro|default("")}\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n{% set runout_resume = True if client.runout_sensor|default("") == ""\nelse True if not printer[client.runout_sensor].enabled\nelse printer[client.runout_sensor].filament_detected %}\n{% set can_extrude = True if printer.toolhead.extruder == \'\'\nelse printer[printer.toolhead.extruder].can_extrude %}\n{% set do_resume = False %}\n\n\n{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False\n{% if last_extruder_temp.restore %}\n\nRESPOND TYPE=echo MSG=\'{"Restoring \\"%s\\" temperature to %3.1f\\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }\'\nM109 S{last_extruder_temp.temp}\n{% set do_resume = True %}\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n\n{% elif can_extrude %}\n{% set do_resume = True %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}\'\n{% endif %}\n{% if runout_resume %}\n{% if do_resume %}\n{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}\n{client.user_resume_macro|default("")}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}\n{% endif %}\n{% else %}\nRESPOND TYPE=error MSG=\'{"Resume aborted !!! \\"%s\\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}\'\n{% endif %}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'variable_restore_idle_timeout': '0', 'variable_idle_state': 'False'}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == \'true\') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != \'\' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'{"\\"%s\\" not hot enough" % printer.toolhead.extruder}\'\n{% endif %}\n{% endif %}', 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'tmc2209 stepper_x': {'uart_pin': 'PC1', 'uart_address': 3, 'diag_pin': 'PA5', 'run_current': 0.86, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 81}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PC2', 'dir_pin': '!PB9', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_x:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC0', 'uart_address': 3, 'diag_pin': 'PA6', 'run_current': 0.9, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 82}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PB8', 'dir_pin': 'PB7', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'tmc2209_stepper_y:virtual_endstop', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 225.0, 'homing_speed': 40.0, 'second_homing_speed': 20.0, 'homing_retract_speed': 40.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PA15', 'uart_address': 3, 'diag_pin': 'PA7', 'run_current': 1.0, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PB6', 'dir_pin': '!PB5', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -4.0, 'position_max': 261.0, 'homing_speed': 4.0, 'second_homing_speed': 2.0, 'homing_retract_speed': 4.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PC14', 'uart_address': 3, 'run_current': 0.55, 'hold_current': 2.0, 'sense_resistor': 0.15, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC5', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 23.94, 'pid_ki': 1.629, 'pid_kd': 87.981, 'heater_pin': 'PA1', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 79.82432411074329, 'max_extrude_only_accel': 798.2432411074329, 'max_extrude_only_distance': 100.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PB4', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': '!PB3', 'rotation_distance': 4.56, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC3'}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PC4', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 69.445, 'pid_ki': 1.146, 'pid_kd': 1052.087, 'heater_pin': 'PA2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA0'}, 'probe': {'z_offset': -0.23, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'PB1', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': 28.0, 'y_offset': -20.0, 'samples': 2, 'sample_retract_dist': 2.0, 'samples_result': 'average', 'samples_tolerance': 0.015, 'samples_tolerance_retries': 5}, 'safe_z_home': {'home_xy_position': [85.0, 135.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 50.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [10], 'mesh_min': [28.0, 20.0], 'mesh_max': [210.0, 205.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'display': {'lcd_type': 'st7920', 'cs_pin': 'PB12', 'sclk_pin': 'PB13', 'sid_pin': 'PB15', 'menu_root': '__main', 'menu_timeout': 0, 'menu_reverse_navigation': False, 'encoder_pins': '^PB14, ^PB10', 'encoder_steps_per_detent': 4, 'encoder_fast_rate': 0.03, 'click_pin': '^!PB2', 'display_group': '_default_16x4'}, 'gcode_macro update_git': {'gcode': '\nRUN_SHELL_COMMAND CMD=update_git_script', 'description': 'G-Code macro'}, 'gcode_shell_command update_git_script': {'command': 'bash /home/biqu/printer_data/klipper-backup/script.sh', 'timeout': 90.0, 'verbose': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-12-02 13:50:32,224 [printer.py:reinit()] - Klipper version: v0.12.0-8-g187cc2f1-dirty
2023-12-02 13:50:32,225 [printer.py:reinit()] - # Extruders: 1
2023-12-02 13:50:32,225 [printer.py:reinit()] - # Temperature devices: 1
2023-12-02 13:50:32,226 [printer.py:reinit()] - # Fans: 1
2023-12-02 13:50:32,226 [printer.py:reinit()] - # Output pins: 0
2023-12-02 13:50:32,226 [printer.py:reinit()] - # Leds: 0
2023-12-02 13:50:32,256 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-12-02 13:50:32,259 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-12-02 13:50:32,534 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&fan
2023-12-02 13:50:32,565 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-12-02 13:50:32,567 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-12-02 13:50:32,568 [files.py:initialize()] - Gcodes path: /home/biqu/SV06_data/gcodes
2023-12-02 13:50:32,569 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-12-02 13:50:32,571 [screen.py:init_printer()] - Printer initialized
2023-12-02 13:50:32,572 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-12-02 13:50:32,573 [printer.py:change_state()] - Adding callback for state: startup
2023-12-02 13:50:33,965 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-12-02 13:50:33,966 [printer.py:change_state()] - Adding callback for state: ready
2023-12-02 13:50:33,973 [screen.py:_load_panel()] - Loading panel: main_menu
2023-12-02 13:50:34,152 [main_menu.py:__init__()] - ### Making MainMenu
2023-12-02 13:50:34,171 [main_menu.py:add_device()] - Adding device: extruder
2023-12-02 13:50:34,187 [main_menu.py:add_device()] - Adding device: heater_bed
2023-12-02 13:50:34,263 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-12-02 13:50:34,267 [main_menu.py:update_graph_visibility()] - Could not create graph tempstore: []
2023-12-02 13:50:37,616 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-12-02 13:50:37,643 [printer.py:init_temp_store()] - Temp store: ['heater_bed', 'extruder']
2023-12-02 13:50:37,678 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-12-02 13:50:37,680 [screen.py:init_tempstore()] - Temperature store size: 1200
